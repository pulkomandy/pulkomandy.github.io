
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>SonixCamDevice.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2004-2008, François Revol, &lt;revol@free.fr&gt;.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;SonixCamDevice.h&quot;</a>
<a name="ln7">#include &quot;CamDebug.h&quot;</a>
<a name="ln8">#include &quot;CamSensor.h&quot;</a>
<a name="ln9">#include &quot;CamBufferingDeframer.h&quot;</a>
<a name="ln10">#include &quot;CamStreamingDeframer.h&quot;</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;ParameterWeb.h&gt;</a>
<a name="ln13">#include &lt;interface/Bitmap.h&gt;</a>
<a name="ln14">#include &lt;media/Buffer.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">const usb_webcam_support_descriptor kSupportedDevices[] = {</a>
<a name="ln17">{{ 0, 0, 0, 0x0c45, 0x6005 }, &quot;Sonix&quot;, &quot;Sonix&quot;, &quot;tas5110c1b&quot; }, // mine</a>
<a name="ln18">{{ 0, 0, 0, 0x0c45, 0x6007 }, &quot;Sonix&quot;, &quot;macally ICECAM&quot;, &quot;tas5110c1b&quot; }, // Rajah's cam - SN9C101R</a>
<a name="ln19">{{ 0, 0, 0, 0x0c45, 0x6009 }, &quot;Trust&quot;, &quot;spacec@m 120&quot;, NULL },</a>
<a name="ln20">{{ 0, 0, 0, 0x0c45, 0x600d }, &quot;Trust&quot;, &quot;spacec@m 120&quot;, NULL },</a>
<a name="ln21"> </a>
<a name="ln22">/* other devices that should be supported,</a>
<a name="ln23"> * cf. sn9c102-1.15 linux driver, sn9c102_sensor.h</a>
<a name="ln24"> * for IDs and sensors</a>
<a name="ln25"> */</a>
<a name="ln26">{{ 0, 0, 0, 0x0c45, 0x6001 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, &quot;tas5110c1b&quot; },</a>
<a name="ln27">{{ 0, 0, 0, 0x0c45, 0x6024 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln28">{{ 0, 0, 0, 0x0c45, 0x6025 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, &quot;tas5110c1b,XXX&quot; },</a>
<a name="ln29">{{ 0, 0, 0, 0x0c45, 0x6028 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln30">{{ 0, 0, 0, 0x0c45, 0x6029 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln31">{{ 0, 0, 0, 0x0c45, 0x602a }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln32">{{ 0, 0, 0, 0x0c45, 0x602b }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln33">{{ 0, 0, 0, 0x0c45, 0x602c }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln34">{{ 0, 0, 0, 0x0c45, 0x6030 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln35">{{ 0, 0, 0, 0x0c45, 0x6080 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln36">{{ 0, 0, 0, 0x0c45, 0x6082 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln37">{{ 0, 0, 0, 0x0c45, 0x6083 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln38">{{ 0, 0, 0, 0x0c45, 0x6088 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln39">{{ 0, 0, 0, 0x0c45, 0x608a }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln40">{{ 0, 0, 0, 0x0c45, 0x608b }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln41">{{ 0, 0, 0, 0x0c45, 0x608c }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln42">{{ 0, 0, 0, 0x0c45, 0x608e }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln43">{{ 0, 0, 0, 0x0c45, 0x608f }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln44">{{ 0, 0, 0, 0x0c45, 0x60a0 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln45">{{ 0, 0, 0, 0x0c45, 0x60a2 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln46">{{ 0, 0, 0, 0x0c45, 0x60a3 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln47">{{ 0, 0, 0, 0x0c45, 0x60a8 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln48">{{ 0, 0, 0, 0x0c45, 0x60aa }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln49">{{ 0, 0, 0, 0x0c45, 0x60ab }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, &quot;tas5110c1b&quot; },</a>
<a name="ln50">{{ 0, 0, 0, 0x0c45, 0x60ac }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln51">{{ 0, 0, 0, 0x0c45, 0x60ae }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln52">{{ 0, 0, 0, 0x0c45, 0x60af }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln53">{{ 0, 0, 0, 0x0c45, 0x60b0 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln54">{{ 0, 0, 0, 0x0c45, 0x60b2 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln55">{{ 0, 0, 0, 0x0c45, 0x60b3 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln56">{{ 0, 0, 0, 0x0c45, 0x60b8 }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln57">{{ 0, 0, 0, 0x0c45, 0x60ba }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln58">{{ 0, 0, 0, 0x0c45, 0x60bb }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln59">{{ 0, 0, 0, 0x0c45, 0x60bc }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln60">{{ 0, 0, 0, 0x0c45, 0x60be }, &quot;Sonix&quot;, &quot;Sonix generic&quot;, NULL },</a>
<a name="ln61">{{ 0, 0, 0, 0, 0}, NULL, NULL, NULL }</a>
<a name="ln62">};</a>
<a name="ln63"> </a>
<a name="ln64">// 12 bytes actually</a>
<a name="ln65">static const uint8 sof_mark_1[] = { 0xff, 0xff, 0x00, 0xc4, 0xc4, 0x96, 0x00 };</a>
<a name="ln66">static const uint8 sof_mark_2[] = { 0xff, 0xff, 0x00, 0xc4, 0xc4, 0x96, 0x01 };</a>
<a name="ln67">static const uint8 *sof_marks[] = { sof_mark_1, sof_mark_2 };</a>
<a name="ln68"> </a>
<a name="ln69">static const uint8 eof_mark_1[] = { 0x00, 0x00, 0x00, 0x00 };</a>
<a name="ln70">static const uint8 eof_mark_2[] = { 0x40, 0x00, 0x00, 0x00 };</a>
<a name="ln71">static const uint8 eof_mark_3[] = { 0x80, 0x00, 0x00, 0x00 };</a>
<a name="ln72">static const uint8 eof_mark_4[] = { 0xc0, 0x00, 0x00, 0x00 };</a>
<a name="ln73">static const uint8 *eof_marks[] = { eof_mark_1, eof_mark_2, eof_mark_3, eof_mark_4 };</a>
<a name="ln74"> </a>
<a name="ln75">void bayer2rgb24(unsigned char *dst, unsigned char *src, long int WIDTH, long int HEIGHT);</a>
<a name="ln76">void bayer2rgb32le(unsigned char *dst, unsigned char *src, long int WIDTH, long int HEIGHT);</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">SonixCamDevice::SonixCamDevice(CamDeviceAddon &amp;_addon, BUSBDevice* _device)</a>
<a name="ln80">          :CamDevice(_addon, _device)</a>
<a name="ln81">{</a>
<a name="ln82">	uchar data[8]; /* store bytes returned from sonix commands */</a>
<a name="ln83">	status_t err;</a>
<a name="ln84">	fFrameTagState = 0;</a>
<a name="ln85"> </a>
<a name="ln86">	fRGain = fGGain = fBGain = 0;</a>
<a name="ln87">	// unknown</a>
<a name="ln88">	fBrightness = 0.5;</a>
<a name="ln89"> </a>
<a name="ln90">	memset(fCachedRegs, 0, SN9C102_REG_COUNT);</a>
<a name="ln91">	fChipVersion = 2;</a>
<a name="ln92">	if ((GetDevice()-&gt;ProductID() &amp; ~0x3F) == 0x6080) {</a>
<a name="ln93">		fChipVersion = 3; // says V4L2</a>
<a name="ln94">	}</a>
<a name="ln95">	err = ProbeSensor();</a>
<a name="ln96"> </a>
<a name="ln97">//	fDeframer = new CamBufferingDeframer(this);</a>
<a name="ln98">	fDeframer = new CamStreamingDeframer(this);</a>
<a name="ln99">	fDeframer-&gt;RegisterSOFTags(sof_marks, 2, sizeof(sof_mark_1), 12);</a>
<a name="ln100">	fDeframer-&gt;RegisterEOFTags(eof_marks, 4, sizeof(eof_mark_1), sizeof(eof_mark_1));</a>
<a name="ln101">	SetDataInput(fDeframer);</a>
<a name="ln102"> </a>
<a name="ln103">	/* init hw */</a>
<a name="ln104"> </a>
<a name="ln105">	const BUSBConfiguration *config = GetDevice()-&gt;ConfigurationAt(0);</a>
<a name="ln106">	if (config) {</a>
<a name="ln107">		const BUSBInterface *inter = config-&gt;InterfaceAt(0);</a>
<a name="ln108">		uint32 i;</a>
<a name="ln109"> </a>
<a name="ln110">		GetDevice()-&gt;SetConfiguration(config);</a>
<a name="ln111"> </a>
<a name="ln112">		for (i = 0; inter &amp;&amp; (i &lt; inter-&gt;CountEndpoints()); i++) {</a>
<a name="ln113">			const BUSBEndpoint *e = inter-&gt;EndpointAt(i);</a>
<a name="ln114">			if (e &amp;&amp; e-&gt;IsBulk() &amp;&amp; e-&gt;IsInput()) {</a>
<a name="ln115">				fBulkIn = e;</a>
<a name="ln116">				PRINT((CH &quot;: Using inter[0].endpoint[%d]; maxpktsz: %d&quot; CT, i, e-&gt;MaxPacketSize()));</a>
<a name="ln117">				break;</a>
<a name="ln118">			}</a>
<a name="ln119">		}</a>
<a name="ln120"> </a>
<a name="ln121">	}</a>
<a name="ln122"> </a>
<a name="ln123">	/* sanity check */</a>
<a name="ln124">	err = ReadReg(SN9C102_ASIC_ID, data);</a>
<a name="ln125">	if (err &lt; 0 || data[0] != 0x10) {</a>
<a name="ln126">		PRINT((CH &quot;: BAD ASIC signature! (%u != %u)&quot; CT, data[0], 0x10));</a>
<a name="ln127">		return;</a>
<a name="ln128">	}</a>
<a name="ln129"> </a>
<a name="ln130">		//XXX: the XP driver sends this to the ICECAM... need to investigate.</a>
<a name="ln131">#if 1</a>
<a name="ln132">	uint8 tmp_3[] = {</a>
<a name="ln133">		0x44, 0x44, 0x00, 0x00, 0x00, 0x04, 0x00, 0xa0,</a>
<a name="ln134">		0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,</a>
<a name="ln135">		0x00, 0x41, 0x09, 0x00, 0x16, 0x12, 0x60, 0x86,</a>
<a name="ln136">		0x3b, 0x0f, 0x0e, 0x06, 0x00, 0x00, 0x03 };</a>
<a name="ln137">	WriteReg(SN9C102_CHIP_CTRL, tmp_3, 0x1f);</a>
<a name="ln138">#endif</a>
<a name="ln139">		//XXX:DEBUG</a>
<a name="ln140"> </a>
<a name="ln141">#if 0</a>
<a name="ln142">		//XXX: the XP driver sends all this... investigate.</a>
<a name="ln143">	uint8 tmp_1[] = {0x09, 0x44};</a>
<a name="ln144">	WriteReg(SN9C102_CHIP_CTRL, tmp_1, sizeof(tmp_1));</a>
<a name="ln145">	WriteReg8(SN9C102_CHIP_CTRL, 0x44);</a>
<a name="ln146"> </a>
<a name="ln147">	WriteReg8(SN9C102_CLOCK_SEL /*0x17*/, 0x29);</a>
<a name="ln148"> </a>
<a name="ln149">	uint8 tmp_2[] = {0x44, 0x44};</a>
<a name="ln150">	WriteReg(SN9C102_CHIP_CTRL, tmp_2, 2);</a>
<a name="ln151">		//URB_FUNCTION_VENDOR_INTERFACE:</a>
<a name="ln152">		//(USBD_TRANSFER_DIRECTION_OUT, ~USBD_SHORT_TRANSFER_OK)</a>
<a name="ln153"> </a>
<a name="ln154">	uint8 tmp_3[] = {</a>
<a name="ln155">		0x44, 0x44, 0x00, 0x00, 0x00, 0x04, 0x00, 0xa0,</a>
<a name="ln156">		0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,</a>
<a name="ln157">		0x00, 0x41, 0x09, 0x00, 0x16, 0x12, 0x60, 0x86,</a>
<a name="ln158">		0x3b, 0x0f, 0x0e, 0x06, 0x00, 0x00, 0x03 };</a>
<a name="ln159">	WriteReg(SN9C102_CHIP_CTRL, tmp_3, 0x1f);</a>
<a name="ln160"> </a>
<a name="ln161">	uint8 tmp_4[] = {0x01, 0x01, 0x07, 0x06};</a>
<a name="ln162">	//WriteReg(SN9C102_AE_STRX, tmp_4, 4);</a>
<a name="ln163"> </a>
<a name="ln164">	uint8 tmp_5[] = {0x14, 0x0f};</a>
<a name="ln165">	//WriteReg(SN9C102_H_SIZE, tmp_5, 2);</a>
<a name="ln166"> </a>
<a name="ln167">	WriteReg8(SN9C102_SYNC_N_SCALE, 0x86);</a>
<a name="ln168"> </a>
<a name="ln169">	WriteReg8(SN9C102_CHIP_CTRL, 0x44);	// again ??</a>
<a name="ln170"> </a>
<a name="ln171">	uint8 tmp_6[] = { 0x60, 0x86 };</a>
<a name="ln172">	WriteReg(SN9C102_CLOCK_SEL /*0x17*/, tmp_6, 2);</a>
<a name="ln173"> </a>
<a name="ln174">	WriteReg8(SN9C102_PIX_CLK, 0x2b);</a>
<a name="ln175"> </a>
<a name="ln176">	// some IIC stuff for the sensor</a>
<a name="ln177">	uint8 tmp_7[] = { 0xb0, 0x61, 0x1c, 0xf8, 0x10, 0x00, 0x00, 0x16 };</a>
<a name="ln178">	//WriteReg(SN9C102_I2C_SETUP, tmp_7, 8);</a>
<a name="ln179"> </a>
<a name="ln180">	WriteReg8(SN9C102_PIX_CLK, 0x4b);</a>
<a name="ln181"> </a>
<a name="ln182">	uint8 tmp_8[] = { 0xa0, 0x61, 0x1c, 0x0f, 0x10, 0x00, 0x00, 0x16 };</a>
<a name="ln183">	//WriteReg(SN9C102_I2C_SETUP, tmp_8, 8);</a>
<a name="ln184"> </a>
<a name="ln185">#endif</a>
<a name="ln186">#if 0</a>
<a name="ln187">	// some IIC stuff for the sensor</a>
<a name="ln188">	uint8 tmp_7[] = { 0xb0, 0x61, 0x1c, 0xf8, 0x10, 0x00, 0x00, 0x16 };</a>
<a name="ln189">	WriteReg(SN9C102_I2C_SETUP, tmp_7, 8);</a>
<a name="ln190"> </a>
<a name="ln191">	WriteReg8(SN9C102_PIX_CLK, 0x4b);</a>
<a name="ln192"> </a>
<a name="ln193">	uint8 tmp_8[] = { 0xa0, 0x61, 0x1c, 0x0f, 0x10, 0x00, 0x00, 0x16};</a>
<a name="ln194">	WriteReg(SN9C102_I2C_SETUP, tmp_8, 8);</a>
<a name="ln195">#endif</a>
<a name="ln196"> </a>
<a name="ln197">	//WriteReg8(SN9C102_PIX_CLK, 0x4b);</a>
<a name="ln198"> </a>
<a name="ln199">//###############</a>
<a name="ln200"> </a>
<a name="ln201">	if (Sensor()) {</a>
<a name="ln202">		PRINT((CH &quot;: CamSensor: %s&quot; CT, Sensor()-&gt;Name()));</a>
<a name="ln203">		fInitStatus = Sensor()-&gt;Setup();</a>
<a name="ln204"> </a>
<a name="ln205">		fVideoFrame = BRect(0, 0, Sensor()-&gt;MaxWidth()-1, Sensor()-&gt;MaxHeight()-1);</a>
<a name="ln206">//		SetVideoFrame(BRect(0, 0, Sensor()-&gt;MaxWidth()-1, Sensor()-&gt;MaxHeight()-1));</a>
<a name="ln207">//		SetVideoFrame(BRect(0, 0, 320-1, 240-1));</a>
<a name="ln208">	}</a>
<a name="ln209">	//SetScale(1);</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212"> </a>
<a name="ln213">SonixCamDevice::~SonixCamDevice()</a>
<a name="ln214">{</a>
<a name="ln215">	if (Sensor())</a>
<a name="ln216">		delete fSensor;</a>
<a name="ln217">	fSensor = NULL;</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220"> </a>
<a name="ln221">bool</a>
<a name="ln222">SonixCamDevice::SupportsBulk()</a>
<a name="ln223">{</a>
<a name="ln224">	return true;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227"> </a>
<a name="ln228">bool</a>
<a name="ln229">SonixCamDevice::SupportsIsochronous()</a>
<a name="ln230">{</a>
<a name="ln231">	return true;</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234"> </a>
<a name="ln235">status_t</a>
<a name="ln236">SonixCamDevice::StartTransfer()</a>
<a name="ln237">{</a>
<a name="ln238">	status_t err;</a>
<a name="ln239">	uint8 r;</a>
<a name="ln240"> </a>
<a name="ln241">	SetScale(1);</a>
<a name="ln242">	if (Sensor())</a>
<a name="ln243">		SetVideoFrame(fVideoFrame);</a>
<a name="ln244"> </a>
<a name="ln245">	//SetVideoFrame(BRect(0, 0, 320-1, 240-1));</a>
<a name="ln246"> </a>
<a name="ln247">DumpRegs();</a>
<a name="ln248">	err = ReadReg(SN9C102_CHIP_CTRL, &amp;r, 1, true);</a>
<a name="ln249">	if (err &lt; 0)</a>
<a name="ln250">		return err;</a>
<a name="ln251">	r |= 0x04;</a>
<a name="ln252">	err = WriteReg8(SN9C102_CHIP_CTRL, r);</a>
<a name="ln253">	if (err &lt; 0)</a>
<a name="ln254">		return err;</a>
<a name="ln255">	return CamDevice::StartTransfer();</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258"> </a>
<a name="ln259">status_t</a>
<a name="ln260">SonixCamDevice::StopTransfer()</a>
<a name="ln261">{</a>
<a name="ln262">	status_t err;</a>
<a name="ln263">	uint8 r;</a>
<a name="ln264"> </a>
<a name="ln265">DumpRegs();</a>
<a name="ln266">	err = CamDevice::StopTransfer();</a>
<a name="ln267">//	if (err &lt; 0)</a>
<a name="ln268">//		return err;</a>
<a name="ln269">	err = ReadReg(SN9C102_CHIP_CTRL, &amp;r, 1, true);</a>
<a name="ln270">	if (err &lt; 0)</a>
<a name="ln271">		return err;</a>
<a name="ln272">	r &amp;= ~0x04;</a>
<a name="ln273">	err = WriteReg8(SN9C102_CHIP_CTRL, r);</a>
<a name="ln274">	if (err &lt; 0)</a>
<a name="ln275">		return err;</a>
<a name="ln276">	return err;</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279"> </a>
<a name="ln280">status_t</a>
<a name="ln281">SonixCamDevice::PowerOnSensor(bool on)</a>
<a name="ln282">{</a>
<a name="ln283">	if (OrReg8(SN9C102_CHIP_CTRL, on ? 0x01 : 0x00) &lt; 0)</a>
<a name="ln284">		return EIO;</a>
<a name="ln285">	return B_OK;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288"> </a>
<a name="ln289">ssize_t</a>
<a name="ln290">SonixCamDevice::WriteReg(uint16 address, uint8 *data, size_t count)</a>
<a name="ln291">{</a>
<a name="ln292">	PRINT((CH &quot;(%u, @%p, %u)&quot; CT, address, data, count));</a>
<a name="ln293">	status_t err;</a>
<a name="ln294">	if (address + count &gt; SN9C102_REG_COUNT) {</a>
<a name="ln295">		PRINT((CH &quot;: Invalid register range [%u;%u]&quot; CT, address, address+count));</a>
<a name="ln296">		return EINVAL;</a>
<a name="ln297">	}</a>
<a name="ln298">	memcpy(&amp;fCachedRegs[address], data, count);</a>
<a name="ln299">	err = SendCommand(USB_REQTYPE_DEVICE_OUT, 0x08, address, 0, count, data);</a>
<a name="ln300">	if (err &lt; B_OK)</a>
<a name="ln301">		return err;</a>
<a name="ln302">	return count;</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305"> </a>
<a name="ln306">ssize_t</a>
<a name="ln307">SonixCamDevice::ReadReg(uint16 address, uint8 *data, size_t count, bool cached)</a>
<a name="ln308">{</a>
<a name="ln309">	PRINT((CH &quot;(%u, @%p, %u, %d)&quot; CT, address, data, count, cached));</a>
<a name="ln310">	status_t err;</a>
<a name="ln311">	if (address + count &gt; SN9C102_REG_COUNT) {</a>
<a name="ln312">		PRINT((CH &quot;: Invalid register range [%u;%u]&quot; CT, address, address+count));</a>
<a name="ln313">		return EINVAL;</a>
<a name="ln314">	}</a>
<a name="ln315">	if (cached) {</a>
<a name="ln316">		memcpy(data, &amp;fCachedRegs[address], count);</a>
<a name="ln317">		return count;</a>
<a name="ln318">	}</a>
<a name="ln319">	err = SendCommand(USB_REQTYPE_DEVICE_IN, 0x00, address, 0, count, data);</a>
<a name="ln320">	if (err &lt; B_OK)</a>
<a name="ln321">		return err;</a>
<a name="ln322">	return count;</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">status_t</a>
<a name="ln327">SonixCamDevice::GetStatusIIC()</a>
<a name="ln328">{</a>
<a name="ln329">	status_t err;</a>
<a name="ln330">	uint8 status = 0;</a>
<a name="ln331">	err = ReadReg(SN9C102_I2C_SETUP, &amp;status);</a>
<a name="ln332">	//dprintf(ID &quot;i2c_status: error 0x%08lx, status = %02x\n&quot;, err, status);</a>
<a name="ln333">	if (err &lt; 0)</a>
<a name="ln334">		return err;</a>
<a name="ln335">	return (status&amp;0x08)?EIO:0;</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338"> </a>
<a name="ln339">status_t</a>
<a name="ln340">SonixCamDevice::WaitReadyIIC()</a>
<a name="ln341">{</a>
<a name="ln342">	status_t err;</a>
<a name="ln343">	uint8 status = 0;</a>
<a name="ln344">	int tries = 5;</a>
<a name="ln345">	if (!Sensor())</a>
<a name="ln346">		return B_NO_INIT;</a>
<a name="ln347">	while (tries--) {</a>
<a name="ln348">		err = ReadReg(SN9C102_I2C_SETUP, &amp;status);</a>
<a name="ln349">		//dprintf(ID &quot;i2c_wait_ready: error 0x%08lx, status = %02x\n&quot;, err, status);</a>
<a name="ln350">		if (err &lt; 0) return err;</a>
<a name="ln351">		if (status &amp; 0x04) return B_OK;</a>
<a name="ln352">		//XXX:FIXME:spin((1+5+11*dev-&gt;sensor-&gt;use_400kHz)*8);</a>
<a name="ln353">		snooze((1+5+11*Sensor()-&gt;Use400kHz())*8);</a>
<a name="ln354">	}</a>
<a name="ln355">	return EBUSY;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358"> </a>
<a name="ln359">ssize_t</a>
<a name="ln360">SonixCamDevice::WriteIIC(uint8 address, uint8 *data, size_t count)</a>
<a name="ln361">{</a>
<a name="ln362">	status_t err;</a>
<a name="ln363">	uint8 buffer[8];</a>
<a name="ln364">	PRINT((CH &quot;(%u, @%p, %u)&quot; CT, address, data, count));</a>
<a name="ln365"> </a>
<a name="ln366">	if (!Sensor())</a>
<a name="ln367">		return B_NO_INIT;</a>
<a name="ln368">	//dprintf(ID &quot;sonix_i2c_write_multi(, %02x, %d, {%02x, %02x, %02x, %02x, %02x})\n&quot;, slave, count, d0, d1, d2, d3, d4);</a>
<a name="ln369">	count++; // includes address</a>
<a name="ln370">	if (count &gt; 5)</a>
<a name="ln371">		return EINVAL;</a>
<a name="ln372">	buffer[0] = ((count) &lt;&lt; 4) | (Sensor()-&gt;Use400kHz()?0x01:0)</a>
<a name="ln373">							 | (Sensor()-&gt;UseRealIIC()?0x80:0);</a>
<a name="ln374">	buffer[1] = Sensor()-&gt;IICWriteAddress();</a>
<a name="ln375">	buffer[2] = address;</a>
<a name="ln376">	memset(&amp;buffer[3], 0, 5);</a>
<a name="ln377">	memcpy(&amp;buffer[3], data, count-1);</a>
<a name="ln378">	buffer[7] = 0x16; /* V4L2 driver uses 0x10, XP driver uses 0x16 ? */</a>
<a name="ln379">	for (int i = 0; i &lt; 8; i++) {</a>
<a name="ln380">		PRINT((&quot;[%d] = %02x\n&quot;, i, buffer[i]));</a>
<a name="ln381">	}</a>
<a name="ln382">	err = WriteReg(SN9C102_I2C_SETUP, buffer, 8);</a>
<a name="ln383">	//dprintf(ID &quot;sonix_i2c_write_multi: set_regs error 0x%08lx\n&quot;, err);</a>
<a name="ln384">	//PRINT((CH &quot;: WriteReg: %s&quot; CT, strerror(err)));</a>
<a name="ln385">	if (err &lt; 0) return err;</a>
<a name="ln386">	err = WaitReadyIIC();</a>
<a name="ln387">	//dprintf(ID &quot;sonix_i2c_write_multi: sonix_i2c_wait_ready error 0x%08lx\n&quot;, err);</a>
<a name="ln388">	//PRINT((CH &quot;: Wait: %s&quot; CT, strerror(err)));</a>
<a name="ln389">	if (err) return err;</a>
<a name="ln390">	err = GetStatusIIC();</a>
<a name="ln391">	//dprintf(ID &quot;sonix_i2c_write_multi: sonix_i2c_status error 0x%08lx\n&quot;, err);</a>
<a name="ln392">	//PRINT((CH &quot;: Status: %s&quot; CT, strerror(err)));</a>
<a name="ln393">	if (err) return err;</a>
<a name="ln394">	//dprintf(ID &quot;sonix_i2c_write_multi: succeeded\n&quot;);</a>
<a name="ln395">	PRINT((CH &quot;: success&quot; CT));</a>
<a name="ln396">	return B_OK;</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399"> </a>
<a name="ln400">ssize_t</a>
<a name="ln401">SonixCamDevice::ReadIIC(uint8 address, uint8 *data)</a>
<a name="ln402">{</a>
<a name="ln403">	status_t err, lasterr = B_OK;</a>
<a name="ln404">	uint8 buffer[8];</a>
<a name="ln405">	PRINT((CH &quot;(%u, @%p)&quot; CT, address, data));</a>
<a name="ln406"> </a>
<a name="ln407">	if (!Sensor())</a>
<a name="ln408">		return B_NO_INIT;</a>
<a name="ln409">	//dprintf(ID &quot;sonix_i2c_write_multi(, %02x, %d, {%02x, %02x, %02x, %02x, %02x})\n&quot;, slave, count, d0, d1, d2, d3, d4);</a>
<a name="ln410">	buffer[0] = (1 &lt;&lt; 4) | (Sensor()-&gt;Use400kHz()?0x01:0)</a>
<a name="ln411">						| (Sensor()-&gt;UseRealIIC()?0x80:0);</a>
<a name="ln412">	buffer[1] = Sensor()-&gt;IICWriteAddress();</a>
<a name="ln413">	buffer[2] = address;</a>
<a name="ln414">	buffer[7] = 0x10; /* absolutely no idea why V4L2 driver use that value */</a>
<a name="ln415">	err = WriteReg(SN9C102_I2C_SETUP, buffer, 8);</a>
<a name="ln416">	//dprintf(ID &quot;sonix_i2c_write_multi: set_regs error 0x%08lx\n&quot;, err);</a>
<a name="ln417">	if (err &lt; 8) return EIO;</a>
<a name="ln418">	err = WaitReadyIIC();</a>
<a name="ln419">	//dprintf(ID &quot;sonix_i2c_write_multi: sonix_i2c_wait_ready error 0x%08lx\n&quot;, err);</a>
<a name="ln420">	//if (err) return err;</a>
<a name="ln421"> </a>
<a name="ln422"> </a>
<a name="ln423">	//dprintf(ID &quot;sonix_i2c_write_multi(, %02x, %d, {%02x, %02x, %02x, %02x, %02x})\n&quot;, slave, count, d0, d1, d2, d3, d4);</a>
<a name="ln424">	buffer[0] = (1 &lt;&lt; 4) | (Sensor()-&gt;Use400kHz()?0x01:0)</a>
<a name="ln425">				  | 0x02 | (Sensor()-&gt;UseRealIIC()?0x80:0); /* read 1 byte */</a>
<a name="ln426">	buffer[1] = Sensor()-&gt;IICReadAddress();//IICWriteAddress</a>
<a name="ln427">	buffer[7] = 0x10; /* absolutely no idea why V4L2 driver use that value */</a>
<a name="ln428">	err = WriteReg(SN9C102_I2C_SETUP, buffer, 8);</a>
<a name="ln429">	//dprintf(ID &quot;sonix_i2c_write_multi: set_regs error 0x%08lx\n&quot;, err);</a>
<a name="ln430">	if (err &lt; 8) return EIO;</a>
<a name="ln431">	err = WaitReadyIIC();</a>
<a name="ln432">	//dprintf(ID &quot;sonix_i2c_write_multi: sonix_i2c_wait_ready error 0x%08lx\n&quot;, err);</a>
<a name="ln433">	if (err &lt; B_OK) return err;</a>
<a name="ln434"> </a>
<a name="ln435">	err = ReadReg(SN9C102_I2C_DATA0, buffer, 5);</a>
<a name="ln436">	if (err &lt; 5) return EIO;</a>
<a name="ln437"> </a>
<a name="ln438">	err = GetStatusIIC();</a>
<a name="ln439">	//dprintf(ID &quot;sonix_i2c_write_multi: sonix_i2c_status error 0x%08lx\n&quot;, err);</a>
<a name="ln440">	if (err &lt; B_OK) return err;</a>
<a name="ln441">	//dprintf(ID &quot;sonix_i2c_write_multi: succeeded\n&quot;);</a>
<a name="ln442">	if (lasterr) return err;</a>
<a name="ln443"> </a>
<a name="ln444">	/* we should get what we want in buffer[4] according to the V4L2 driver...</a>
<a name="ln445">	 * probably because the 5 bytes are a bit shift register?</a>
<a name="ln446">	 */</a>
<a name="ln447">	*data = buffer[4];</a>
<a name="ln448"> </a>
<a name="ln449">	return 1;</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452"> </a>
<a name="ln453">status_t</a>
<a name="ln454">SonixCamDevice::SetVideoFrame(BRect frame)</a>
<a name="ln455">{</a>
<a name="ln456">	uint16 x, y, width, height;</a>
<a name="ln457">	x = (uint16)frame.left;</a>
<a name="ln458">	y = (uint16)frame.top;</a>
<a name="ln459">	width = (uint16)(frame.right - frame.left + 1) / 16;</a>
<a name="ln460">	height = (uint16)(frame.bottom - frame.top + 1) / 16;</a>
<a name="ln461">	PRINT((CH &quot;(%u, %u, %u, %u)&quot; CT, x, y, width, height));</a>
<a name="ln462"> </a>
<a name="ln463">	WriteReg8(SN9C102_H_START, x);</a>
<a name="ln464">	WriteReg8(SN9C102_V_START, y);</a>
<a name="ln465">	WriteReg8(SN9C102_H_SIZE, width);</a>
<a name="ln466">	WriteReg8(SN9C102_V_SIZE, height);</a>
<a name="ln467">	if (Sensor()) {</a>
<a name="ln468">		Sensor()-&gt;SetVideoFrame(frame);</a>
<a name="ln469">	}</a>
<a name="ln470">	return CamDevice::SetVideoFrame(frame);</a>
<a name="ln471">}</a>
<a name="ln472"> </a>
<a name="ln473"> </a>
<a name="ln474">status_t</a>
<a name="ln475">SonixCamDevice::SetScale(float scale)</a>
<a name="ln476">{</a>
<a name="ln477">	status_t err;</a>
<a name="ln478">	uint8 r;</a>
<a name="ln479">	int iscale = (int)scale;</a>
<a name="ln480"> </a>
<a name="ln481">	PRINT((CH &quot;(%u)&quot; CT, iscale));</a>
<a name="ln482">	err = ReadReg(SN9C102_SYNC_N_SCALE, &amp;r, 1, true);</a>
<a name="ln483">	if (err &lt; 0)</a>
<a name="ln484">		return err;</a>
<a name="ln485">	r &amp;= ~0x30;</a>
<a name="ln486">	switch (iscale) {</a>
<a name="ln487">	case 1:</a>
<a name="ln488">	case 2:</a>
<a name="ln489">	case 4:</a>
<a name="ln490">		r |= ((iscale-1) &lt;&lt; 4);</a>
<a name="ln491">		break;</a>
<a name="ln492">	default:</a>
<a name="ln493">		return EINVAL;</a>
<a name="ln494">	}</a>
<a name="ln495">	err = WriteReg8(SN9C102_SYNC_N_SCALE, r);</a>
<a name="ln496">	return err;</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499"> </a>
<a name="ln500">status_t</a>
<a name="ln501">SonixCamDevice::SetVideoParams(float brightness, float contrast, float hue, float red, float green, float blue)</a>
<a name="ln502">{</a>
<a name="ln503">	return B_OK;</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">void</a>
<a name="ln507">SonixCamDevice::AddParameters(BParameterGroup *group, int32 &amp;index)</a>
<a name="ln508">{</a>
<a name="ln509">	BParameterGroup *g;</a>
<a name="ln510">	BContinuousParameter *p;</a>
<a name="ln511">	CamDevice::AddParameters(group, index);</a>
<a name="ln512"> </a>
<a name="ln513">	// R,G,B gains</a>
<a name="ln514">	g = group-&gt;MakeGroup(&quot;RGB gain&quot;);</a>
<a name="ln515">	p = g-&gt;MakeContinuousParameter(index++,</a>
<a name="ln516">		B_MEDIA_RAW_VIDEO, &quot;RGB gain&quot;,</a>
<a name="ln517">		B_GAIN, &quot;&quot;, 1.0, 1.0+(float)(SN9C102_RGB_GAIN_MAX)/8, (float)1.0/8);</a>
<a name="ln518"> </a>
<a name="ln519">	p-&gt;SetChannelCount(3);</a>
<a name="ln520">#if 0</a>
<a name="ln521">	// Contrast - NON FUNCTIONAL</a>
<a name="ln522">	g = group-&gt;MakeGroup(&quot;Contrast&quot;);</a>
<a name="ln523">	p = g-&gt;MakeContinuousParameter(index++,</a>
<a name="ln524">		B_MEDIA_RAW_VIDEO, &quot;Contrast&quot;,</a>
<a name="ln525">		B_GAIN, &quot;&quot;, 0.0, 1.0, 1.0/256);</a>
<a name="ln526"> </a>
<a name="ln527">	// Brightness - NON FUNCTIONAL</a>
<a name="ln528">	g = group-&gt;MakeGroup(&quot;Brightness&quot;);</a>
<a name="ln529">	p = g-&gt;MakeContinuousParameter(index++,</a>
<a name="ln530">		B_MEDIA_RAW_VIDEO, &quot;Brightness&quot;,</a>
<a name="ln531">		B_GAIN, &quot;&quot;, 0.0, 1.0, 1.0/256);</a>
<a name="ln532"> </a>
<a name="ln533">#endif</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">status_t</a>
<a name="ln537">SonixCamDevice::GetParameterValue(int32 id, bigtime_t *last_change, void *value, size_t *size)</a>
<a name="ln538">{</a>
<a name="ln539">	float *gains;</a>
<a name="ln540">	switch (id - fFirstParameterID) {</a>
<a name="ln541">		case 0:</a>
<a name="ln542">			*size = 3 * sizeof(float);</a>
<a name="ln543">			gains = ((float *)value);</a>
<a name="ln544">			gains[0] = 1.0 + (float)fRGain / 8;</a>
<a name="ln545">			gains[1] = 1.0 + (float)fGGain / 8;</a>
<a name="ln546">			gains[2] = 1.0 + (float)fBGain / 8;</a>
<a name="ln547">			*last_change = fLastParameterChanges;</a>
<a name="ln548">			return B_OK;</a>
<a name="ln549">#if 0</a>
<a name="ln550">		case 1:</a>
<a name="ln551">			*size = sizeof(float);</a>
<a name="ln552">			gains = ((float *)value);</a>
<a name="ln553">			gains[0] = fContrast;</a>
<a name="ln554">			*last_change = fLastParameterChanges;</a>
<a name="ln555">			return B_OK;</a>
<a name="ln556">		case 2:</a>
<a name="ln557">			*size = sizeof(float);</a>
<a name="ln558">			gains = ((float *)value);</a>
<a name="ln559">			gains[0] = fBrightness;</a>
<a name="ln560">			*last_change = fLastParameterChanges;</a>
<a name="ln561">			return B_OK;</a>
<a name="ln562">#endif</a>
<a name="ln563">	}</a>
<a name="ln564">	return B_BAD_VALUE;</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">status_t</a>
<a name="ln568">SonixCamDevice::SetParameterValue(int32 id, bigtime_t when, const void *value, size_t size)</a>
<a name="ln569">{</a>
<a name="ln570">	float *gains;</a>
<a name="ln571">	switch (id - fFirstParameterID) {</a>
<a name="ln572">		case 0:</a>
<a name="ln573">			if (!value || (size != 3 * sizeof(float)))</a>
<a name="ln574">				return B_BAD_VALUE;</a>
<a name="ln575">			gains = ((float *)value);</a>
<a name="ln576">			if ((gains[0] == 1.0 + (float)fRGain / 8)</a>
<a name="ln577">				&amp;&amp; (gains[1] == 1.0 + (float)fGGain / 8)</a>
<a name="ln578">				&amp;&amp; (gains[2] == 1.0 + (float)fBGain / 8))</a>
<a name="ln579">				return B_OK;</a>
<a name="ln580"> </a>
<a name="ln581">			fRGain = (int)(8 * (gains[0] - 1.0)) &amp; SN9C102_RGB_GAIN_MAX;</a>
<a name="ln582">			fGGain = (int)(8 * (gains[1] - 1.0)) &amp; SN9C102_RGB_GAIN_MAX;</a>
<a name="ln583">			fBGain = (int)(8 * (gains[2] - 1.0)) &amp; SN9C102_RGB_GAIN_MAX;</a>
<a name="ln584">			fLastParameterChanges = when;</a>
<a name="ln585">			PRINT((CH &quot;: gain: %d,%d,%d&quot; CT, fRGain, fGGain, fBGain));</a>
<a name="ln586">			//WriteReg8(SN9C102_R_B_GAIN, (fBGain &lt;&lt; 4) | fRGain);	/* red, blue gain = 1+0/8 = 1 */</a>
<a name="ln587">			/* Datasheet says:</a>
<a name="ln588">			 * reg 0x10 [0:3] is rgain, [4:7] is bgain and 0x11 [0:3] is ggain</a>
<a name="ln589">			 * according to sn9c102-1.15 linux driver it's wrong for reg 0x10,</a>
<a name="ln590">			 * but it doesn't seem to work any better for a rev 2 chip.</a>
<a name="ln591">			 * XXX</a>
<a name="ln592">			 */</a>
<a name="ln593">#if 1</a>
<a name="ln594">			WriteReg8(SN9C102_R_GAIN, fRGain);</a>
<a name="ln595">			WriteReg8(SN9C102_B_GAIN, fBGain);</a>
<a name="ln596">			if (fChipVersion &gt;= 3)</a>
<a name="ln597">				WriteReg8(SN9C103_G_GAIN, fGGain);</a>
<a name="ln598">			else</a>
<a name="ln599">				WriteReg8(SN9C102_G_GAIN, (fGGain / 16));</a>
<a name="ln600">#endif</a>
<a name="ln601">#if 0</a>
<a name="ln602">			uint8 buf[2];</a>
<a name="ln603">			buf[0] = (fBGain &lt;&lt; 4) | fRGain;</a>
<a name="ln604">			buf[1] = fGGain;</a>
<a name="ln605">			WriteReg(SN9C102_R_B_GAIN, buf, 2);</a>
<a name="ln606">#endif</a>
<a name="ln607">			return B_OK;</a>
<a name="ln608">#if 0</a>
<a name="ln609">		case 1:</a>
<a name="ln610">			if (!value || (size != sizeof(float)))</a>
<a name="ln611">				return B_BAD_VALUE;</a>
<a name="ln612">			gains = ((float *)value);</a>
<a name="ln613">			fContrast = gains[0];</a>
<a name="ln614">			WriteReg8(SN9C10x_CONTRAST, ((uint8)(fContrast * 256)));</a>
<a name="ln615">			return B_OK;</a>
<a name="ln616">		case 2:</a>
<a name="ln617">			if (!value || (size != sizeof(float)))</a>
<a name="ln618">				return B_BAD_VALUE;</a>
<a name="ln619">			gains = ((float *)value);</a>
<a name="ln620">			fBrightness = gains[0];</a>
<a name="ln621">			// it actually ends up writing to SN9C102_V_SIZE...</a>
<a name="ln622">			WriteReg8(SN9C10x_BRIGHTNESS, ((uint8)(fBrightness * 256)));</a>
<a name="ln623"> </a>
<a name="ln624">			return B_OK;</a>
<a name="ln625">#endif</a>
<a name="ln626">	}</a>
<a name="ln627">	return B_BAD_VALUE;</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630"> </a>
<a name="ln631"> </a>
<a name="ln632">size_t</a>
<a name="ln633">SonixCamDevice::MinRawFrameSize()</a>
<a name="ln634">{</a>
<a name="ln635">	// if (fCompressionEnabled) { ... return ; }</a>
<a name="ln636">	BRect vf(VideoFrame());</a>
<a name="ln637">	int w = vf.IntegerWidth()+1;</a>
<a name="ln638">	int h = vf.IntegerHeight()+1;</a>
<a name="ln639">	// 1 byte/pixel</a>
<a name="ln640">	return (size_t)(w*h);</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643"> </a>
<a name="ln644">size_t</a>
<a name="ln645">SonixCamDevice::MaxRawFrameSize()</a>
<a name="ln646">{</a>
<a name="ln647">	// if (fCompressionEnabled) { ... return ; }</a>
<a name="ln648">	return MinRawFrameSize()+1024*0; // fixed size frame (uncompressed)</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651"> </a>
<a name="ln652">bool</a>
<a name="ln653">SonixCamDevice::ValidateStartOfFrameTag(const uint8 *tag, size_t taglen)</a>
<a name="ln654">{</a>
<a name="ln655">	// SOF come with an 00, 40, 80, C0 sequence,</a>
<a name="ln656">	// supposedly corresponding with an equal byte in the end tag</a>
<a name="ln657">	fFrameTagState = tag[7] &amp; 0xC0;</a>
<a name="ln658">	PRINT((CH &quot;(, %d) state %x&quot; CT, taglen, fFrameTagState));</a>
<a name="ln659"> </a>
<a name="ln660">	// which seems to be the same as of the EOF tag</a>
<a name="ln661">	return true;</a>
<a name="ln662">}</a>
<a name="ln663"> </a>
<a name="ln664"> </a>
<a name="ln665">bool</a>
<a name="ln666">SonixCamDevice::ValidateEndOfFrameTag(const uint8 *tag, size_t taglen, size_t datalen)</a>
<a name="ln667">{</a>
<a name="ln668">	//PRINT((CH &quot;(, %d) %x == %x&quot; CT, taglen, (tag[0] &amp; 0xC0), fFrameTagState));</a>
<a name="ln669">	// make sure the tag corresponds to the SOF we refer to</a>
<a name="ln670">	if ((tag[0] &amp; 0xC0) != fFrameTagState) {</a>
<a name="ln671">		PRINT((CH &quot;: discarded EOF %x != %x&quot; CT, fFrameTagState, tag[0] &amp; 0xC0));</a>
<a name="ln672">		return false;</a>
<a name="ln673">	}</a>
<a name="ln674">	//PRINT((CH &quot;: validated EOF %x, len %d&quot; CT, fFrameTagState, datalen));</a>
<a name="ln675">	return true;</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678"> </a>
<a name="ln679">status_t</a>
<a name="ln680">SonixCamDevice::GetFrameBitmap(BBitmap **bm, bigtime_t *stamp /* = NULL */)</a>
<a name="ln681">{</a>
<a name="ln682">	BBitmap *b;</a>
<a name="ln683">	CamFrame *f;</a>
<a name="ln684">	status_t err;</a>
<a name="ln685">	PRINT((CH &quot;()&quot; CT));</a>
<a name="ln686">	err = fDeframer-&gt;WaitFrame(200000);</a>
<a name="ln687">	if (err &lt; B_OK) { PRINT((CH &quot;: WaitFrame: %s&quot; CT, strerror(err))); }</a>
<a name="ln688">	if (err &lt; B_OK)</a>
<a name="ln689">		return err;</a>
<a name="ln690">	err = fDeframer-&gt;GetFrame(&amp;f, stamp);</a>
<a name="ln691">	if (err &lt; B_OK) { PRINT((CH &quot;: GetFrame: %s&quot; CT, strerror(err))); }</a>
<a name="ln692">	if (err &lt; B_OK)</a>
<a name="ln693">		return err;</a>
<a name="ln694">	PRINT((CH &quot;: VideoFrame = %fx%f,%fx%f&quot; CT, VideoFrame().left, VideoFrame().top, VideoFrame().right, VideoFrame().bottom));</a>
<a name="ln695"> </a>
<a name="ln696">	long int w = (long)(VideoFrame().right - VideoFrame().left + 1);</a>
<a name="ln697">	long int h = (long)(VideoFrame().bottom - VideoFrame().top + 1);</a>
<a name="ln698">	b = new BBitmap(VideoFrame().OffsetToSelf(0,0), 0, B_RGB32, w*4);</a>
<a name="ln699">	PRINT((CH &quot;: Frame: %dx%d&quot; CT, w, h));</a>
<a name="ln700"> </a>
<a name="ln701">	bayer2rgb24((unsigned char *)b-&gt;Bits(), (unsigned char *)f-&gt;Buffer(), w, h);</a>
<a name="ln702"> </a>
<a name="ln703">	PRINT((CH &quot;: got 1 frame (len %d)&quot; CT, b-&gt;BitsLength()));</a>
<a name="ln704">	*bm = b;</a>
<a name="ln705">	return B_OK;</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708"> </a>
<a name="ln709">status_t</a>
<a name="ln710">SonixCamDevice::FillFrameBuffer(BBuffer *buffer, bigtime_t *stamp)</a>
<a name="ln711">{</a>
<a name="ln712">	CamFrame *f;</a>
<a name="ln713">	status_t err;</a>
<a name="ln714">	PRINT((CH &quot;()&quot; CT));</a>
<a name="ln715"> </a>
<a name="ln716">	memset(buffer-&gt;Data(), 0, buffer-&gt;SizeAvailable());</a>
<a name="ln717">	err = fDeframer-&gt;WaitFrame(2000000);</a>
<a name="ln718">	if (err &lt; B_OK) { PRINT((CH &quot;: WaitFrame: %s&quot; CT, strerror(err))); }</a>
<a name="ln719">	if (err &lt; B_OK)</a>
<a name="ln720">		return err;</a>
<a name="ln721"> </a>
<a name="ln722">	err = fDeframer-&gt;GetFrame(&amp;f, stamp);</a>
<a name="ln723">	if (err &lt; B_OK) { PRINT((CH &quot;: GetFrame: %s&quot; CT, strerror(err))); }</a>
<a name="ln724">	if (err &lt; B_OK)</a>
<a name="ln725">		return err;</a>
<a name="ln726"> </a>
<a name="ln727">	long int w = (long)(VideoFrame().right - VideoFrame().left + 1);</a>
<a name="ln728">	long int h = (long)(VideoFrame().bottom - VideoFrame().top + 1);</a>
<a name="ln729">	PRINT((CH &quot;: VideoFrame = %fx%f,%fx%f Frame: %dx%d&quot; CT, VideoFrame().left, VideoFrame().top, VideoFrame().right, VideoFrame().bottom, w, h));</a>
<a name="ln730"> </a>
<a name="ln731">	if (buffer-&gt;SizeAvailable() &gt;= (size_t)w*h*4)</a>
<a name="ln732">		bayer2rgb32le((unsigned char *)buffer-&gt;Data(), (unsigned char *)f-&gt;Buffer(), w, h);</a>
<a name="ln733"> </a>
<a name="ln734">	delete f;</a>
<a name="ln735"> </a>
<a name="ln736">	PRINT((CH &quot;: available %d, required %d&quot; CT, buffer-&gt;SizeAvailable(), w*h*4));</a>
<a name="ln737">	if (buffer-&gt;SizeAvailable() &lt; (size_t)w*h*4)</a>
<a name="ln738">		return E2BIG;</a>
<a name="ln739">	PRINT((CH &quot;: got 1 frame (len %d)&quot; CT, buffer-&gt;SizeUsed()));</a>
<a name="ln740">	return B_OK;</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743"> </a>
<a name="ln744">void</a>
<a name="ln745">/* DEBUG: dump the SN regs */</a>
<a name="ln746">SonixCamDevice::DumpRegs()</a>
<a name="ln747">{</a>
<a name="ln748">	uint8 regs[SN9C102_REG_COUNT];</a>
<a name="ln749">	status_t err;</a>
<a name="ln750"> </a>
<a name="ln751">	//err = sonix_get_regs(dev, SN_ASIC_ID, regs, SN_REG_COUNT);</a>
<a name="ln752">	err = ReadReg(0, regs, SN9C102_REG_COUNT);</a>
<a name="ln753">	if (err &lt; 0)</a>
<a name="ln754">		return;</a>
<a name="ln755">	printf(&quot;REG1: %02x %02x %02x %02x  %02x %02x %02x %02x\n&quot;,</a>
<a name="ln756">			regs[0], regs[1], regs[2], regs[3], regs[4], regs[5], regs[6], regs[7]);</a>
<a name="ln757">	printf(&quot;   2: %02x %02x %02x %02x  %02x %02x %02x %02x\n&quot;,</a>
<a name="ln758">			regs[8], regs[9], regs[10], regs[11], regs[12], regs[13], regs[14], regs[15]);</a>
<a name="ln759">	printf(&quot;   3: %02x %02x %02x %02x  %02x %02x %02x %02x\n&quot;,</a>
<a name="ln760">			regs[16], regs[17], regs[18], regs[19], regs[20], regs[21], regs[22], regs[23]);</a>
<a name="ln761">	printf(&quot;   4: %02x %02x %02x %02x  %02x %02x %02x %02x\n&quot;,</a>
<a name="ln762">			regs[24], regs[25], regs[26], regs[27], regs[28], regs[29], regs[30], regs[31]);</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">#if 0</a>
<a name="ln766"> </a>
<a name="ln767">status_t</a>
<a name="ln768">SonixCamDevice::SendCommand(uint8 dir, uint8 request, uint16 value,</a>
<a name="ln769">							uint16 index, uint16 length, void* data)</a>
<a name="ln770">{</a>
<a name="ln771">	size_t ret;</a>
<a name="ln772">	if (!GetDevice())</a>
<a name="ln773">		return ENODEV;</a>
<a name="ln774">	if (length &gt; GetDevice()-&gt;MaxEndpoint0PacketSize())</a>
<a name="ln775">		return EINVAL;</a>
<a name="ln776">	ret = GetDevice()-&gt;ControlTransfer(</a>
<a name="ln777">				USB_REQTYPE_VENDOR | USB_REQTYPE_INTERFACE_OUT | dir,</a>
<a name="ln778">				request, value, index, length, data);</a>
<a name="ln779">	return ret;</a>
<a name="ln780">}</a>
<a name="ln781">#endif</a>
<a name="ln782"> </a>
<a name="ln783"> </a>
<a name="ln784">SonixCamDeviceAddon::SonixCamDeviceAddon(WebCamMediaAddOn* webcam)</a>
<a name="ln785">	: CamDeviceAddon(webcam)</a>
<a name="ln786">{</a>
<a name="ln787">	SetSupportedDevices(kSupportedDevices);</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790"> </a>
<a name="ln791">SonixCamDeviceAddon::~SonixCamDeviceAddon()</a>
<a name="ln792">{</a>
<a name="ln793">}</a>
<a name="ln794"> </a>
<a name="ln795"> </a>
<a name="ln796">const char *</a>
<a name="ln797">SonixCamDeviceAddon::BrandName()</a>
<a name="ln798">{</a>
<a name="ln799">	return &quot;Sonix&quot;;</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802"> </a>
<a name="ln803">SonixCamDevice *</a>
<a name="ln804">SonixCamDeviceAddon::Instantiate(CamRoster &amp;roster, BUSBDevice *from)</a>
<a name="ln805">{</a>
<a name="ln806">	return new SonixCamDevice(*this, from);</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809">extern &quot;C&quot; status_t</a>
<a name="ln810">B_WEBCAM_MKINTFUNC(sonix)</a>
<a name="ln811">(WebCamMediaAddOn* webcam, CamDeviceAddon **addon)</a>
<a name="ln812">{</a>
<a name="ln813">	*addon = new SonixCamDeviceAddon(webcam);</a>
<a name="ln814">	return B_OK;</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817">// XXX: REMOVE ME</a>
<a name="ln818"> </a>
<a name="ln819"> </a>
<a name="ln820"> </a>
<a name="ln821">/*</a>
<a name="ln822"> * BAYER2RGB24 ROUTINE TAKEN FROM:</a>
<a name="ln823"> *</a>
<a name="ln824"> * Sonix SN9C101 based webcam basic I/F routines</a>
<a name="ln825"> * Copyright (C) 2004 Takafumi Mizuno &lt;taka-qce@ls-a.jp&gt;</a>
<a name="ln826"> *</a>
<a name="ln827"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln828"> * modification, are permitted provided that the following conditions</a>
<a name="ln829"> * are met:</a>
<a name="ln830"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln831"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln832"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln833"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln834"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln835"> *</a>
<a name="ln836"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln837"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln838"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln839"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</a>
<a name="ln840"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln841"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln842"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln843"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln844"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln845"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln846"> * SUCH DAMAGE.</a>
<a name="ln847"> */</a>
<a name="ln848"> </a>
<a name="ln849">void bayer2rgb24(unsigned char *dst, unsigned char *src, long int WIDTH, long int HEIGHT)</a>
<a name="ln850">{</a>
<a name="ln851">    long int i;</a>
<a name="ln852">    unsigned char *rawpt, *scanpt;</a>
<a name="ln853">    long int size;</a>
<a name="ln854"> </a>
<a name="ln855">    rawpt = src;</a>
<a name="ln856">    scanpt = dst;</a>
<a name="ln857">    size = WIDTH*HEIGHT;</a>
<a name="ln858"> </a>
<a name="ln859">    for ( i = 0; i &lt; size; i++ ) {</a>
<a name="ln860">	if ( (i/WIDTH) % 2 == 0 ) {</a>
<a name="ln861">	    if ( (i % 2) == 0 ) {</a>
<a name="ln862">		/* B */</a>
<a name="ln863">		if ( (i &gt; WIDTH) &amp;&amp; ((i % WIDTH) &gt; 0) ) {</a>
<a name="ln864">		    *scanpt++ = (*(rawpt-WIDTH-1)+*(rawpt-WIDTH+1)+</a>
<a name="ln865">				 *(rawpt+WIDTH-1)+*(rawpt+WIDTH+1))/4;	/* R */</a>
<a name="ln866">		    *scanpt++ = (*(rawpt-1)+*(rawpt+1)+</a>
<a name="ln867">				 *(rawpt+WIDTH)+*(rawpt-WIDTH))/4;	/* G */</a>
<a name="ln868">		    *scanpt++ = *rawpt;					/* B */</a>
<a name="ln869">		} else {</a>
<a name="ln870">		    /* first line or left column */</a>
<a name="ln871">		    *scanpt++ = *(rawpt+WIDTH+1);		/* R */</a>
<a name="ln872">		    *scanpt++ = (*(rawpt+1)+*(rawpt+WIDTH))/2;	/* G */</a>
<a name="ln873">		    *scanpt++ = *rawpt;				/* B */</a>
<a name="ln874">		}</a>
<a name="ln875">	    } else {</a>
<a name="ln876">		/* (B)G */</a>
<a name="ln877">		if ( (i &gt; WIDTH) &amp;&amp; ((i % WIDTH) &lt; (WIDTH-1)) ) {</a>
<a name="ln878">		    *scanpt++ = (*(rawpt+WIDTH)+*(rawpt-WIDTH))/2;	/* R */</a>
<a name="ln879">		    *scanpt++ = *rawpt;					/* G */</a>
<a name="ln880">		    *scanpt++ = (*(rawpt-1)+*(rawpt+1))/2;		/* B */</a>
<a name="ln881">		} else {</a>
<a name="ln882">		    /* first line or right column */</a>
<a name="ln883">		    *scanpt++ = *(rawpt+WIDTH);	/* R */</a>
<a name="ln884">		    *scanpt++ = *rawpt;		/* G */</a>
<a name="ln885">		    *scanpt++ = *(rawpt-1);	/* B */</a>
<a name="ln886">		}</a>
<a name="ln887">	    }</a>
<a name="ln888">	} else {</a>
<a name="ln889">	    if ( (i % 2) == 0 ) {</a>
<a name="ln890">		/* G(R) */</a>
<a name="ln891">		if ( (i &lt; (WIDTH*(HEIGHT-1))) &amp;&amp; ((i % WIDTH) &gt; 0) ) {</a>
<a name="ln892">		    *scanpt++ = (*(rawpt-1)+*(rawpt+1))/2;		/* R */</a>
<a name="ln893">		    *scanpt++ = *rawpt;					/* G */</a>
<a name="ln894">		    *scanpt++ = (*(rawpt+WIDTH)+*(rawpt-WIDTH))/2;	/* B */</a>
<a name="ln895">		} else {</a>
<a name="ln896">		    /* bottom line or left column */</a>
<a name="ln897">		    *scanpt++ = *(rawpt+1);		/* R */</a>
<a name="ln898">		    *scanpt++ = *rawpt;			/* G */</a>
<a name="ln899">		    *scanpt++ = *(rawpt-WIDTH);		/* B */</a>
<a name="ln900">		}</a>
<a name="ln901">	    } else {</a>
<a name="ln902">		/* R */</a>
<a name="ln903">		if ( i &lt; (WIDTH*(HEIGHT-1)) &amp;&amp; ((i % WIDTH) &lt; (WIDTH-1)) ) {</a>
<a name="ln904">		    *scanpt++ = *rawpt;					/* R */</a>
<a name="ln905">		    *scanpt++ = (*(rawpt-1)+*(rawpt+1)+</a>
<a name="ln906">				 *(rawpt-WIDTH)+*(rawpt+WIDTH))/4;	/* G */</a>
<a name="ln907">		    *scanpt++ = (*(rawpt-WIDTH-1)+*(rawpt-WIDTH+1)+</a>
<a name="ln908">				 *(rawpt+WIDTH-1)+*(rawpt+WIDTH+1))/4;	/* B */</a>
<a name="ln909">		} else {</a>
<a name="ln910">		    /* bottom line or right column */</a>
<a name="ln911">		    *scanpt++ = *rawpt;				/* R */</a>
<a name="ln912">		    *scanpt++ = (*(rawpt-1)+*(rawpt-WIDTH))/2;	/* G */</a>
<a name="ln913">		    *scanpt++ = *(rawpt-WIDTH-1);		/* B */</a>
<a name="ln914">		}</a>
<a name="ln915">	    }</a>
<a name="ln916">	}</a>
<a name="ln917">	rawpt++;</a>
<a name="ln918">    }</a>
<a name="ln919"> </a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922">/* modified bayer2rgb24 to output rgb-32 little endian (B_RGB32)</a>
<a name="ln923"> * François Revol</a>
<a name="ln924"> */</a>
<a name="ln925"> </a>
<a name="ln926">void bayer2rgb32le(unsigned char *dst, unsigned char *src, long int WIDTH, long int HEIGHT)</a>
<a name="ln927">{</a>
<a name="ln928">    long int i;</a>
<a name="ln929">    unsigned char *rawpt, *scanpt;</a>
<a name="ln930">    long int size;</a>
<a name="ln931"> </a>
<a name="ln932">    rawpt = src;</a>
<a name="ln933">    scanpt = dst;</a>
<a name="ln934">    size = WIDTH*HEIGHT;</a>
<a name="ln935"> </a>
<a name="ln936">    for ( i = 0; i &lt; size; i++ ) {</a>
<a name="ln937">	if ( (i/WIDTH) % 2 == 0 ) {</a>
<a name="ln938">	    if ( (i % 2) == 0 ) {</a>
<a name="ln939">		/* B */</a>
<a name="ln940">		if ( (i &gt; WIDTH) &amp;&amp; ((i % WIDTH) &gt; 0) ) {</a>
<a name="ln941">		    *scanpt++ = *rawpt;					/* B */</a>
<a name="ln942">		    *scanpt++ = (*(rawpt-1)+*(rawpt+1)+</a>
<a name="ln943">				 *(rawpt+WIDTH)+*(rawpt-WIDTH))/4;	/* G */</a>
<a name="ln944">		    *scanpt++ = (*(rawpt-WIDTH-1)+*(rawpt-WIDTH+1)+</a>
<a name="ln945">				 *(rawpt+WIDTH-1)+*(rawpt+WIDTH+1))/4;	/* R */</a>
<a name="ln946">		} else {</a>
<a name="ln947">		    /* first line or left column */</a>
<a name="ln948">		    *scanpt++ = *rawpt;				/* B */</a>
<a name="ln949">		    *scanpt++ = (*(rawpt+1)+*(rawpt+WIDTH))/2;	/* G */</a>
<a name="ln950">		    *scanpt++ = *(rawpt+WIDTH+1);		/* R */</a>
<a name="ln951">		}</a>
<a name="ln952">	    } else {</a>
<a name="ln953">		/* (B)G */</a>
<a name="ln954">		if ( (i &gt; WIDTH) &amp;&amp; ((i % WIDTH) &lt; (WIDTH-1)) ) {</a>
<a name="ln955">		    *scanpt++ = (*(rawpt-1)+*(rawpt+1))/2;		/* B */</a>
<a name="ln956">		    *scanpt++ = *rawpt;					/* G */</a>
<a name="ln957">		    *scanpt++ = (*(rawpt+WIDTH)+*(rawpt-WIDTH))/2;	/* R */</a>
<a name="ln958">		} else {</a>
<a name="ln959">		    /* first line or right column */</a>
<a name="ln960">		    *scanpt++ = *(rawpt-1);	/* B */</a>
<a name="ln961">		    *scanpt++ = *rawpt;		/* G */</a>
<a name="ln962">		    *scanpt++ = *(rawpt+WIDTH);	/* R */</a>
<a name="ln963">		}</a>
<a name="ln964">	    }</a>
<a name="ln965">	} else {</a>
<a name="ln966">	    if ( (i % 2) == 0 ) {</a>
<a name="ln967">		/* G(R) */</a>
<a name="ln968">		if ( (i &lt; (WIDTH*(HEIGHT-1))) &amp;&amp; ((i % WIDTH) &gt; 0) ) {</a>
<a name="ln969">		    *scanpt++ = (*(rawpt+WIDTH)+*(rawpt-WIDTH))/2;	/* B */</a>
<a name="ln970">		    *scanpt++ = *rawpt;					/* G */</a>
<a name="ln971">		    *scanpt++ = (*(rawpt-1)+*(rawpt+1))/2;		/* R */</a>
<a name="ln972">		} else {</a>
<a name="ln973">		    /* bottom line or left column */</a>
<a name="ln974">		    *scanpt++ = *(rawpt-WIDTH);		/* B */</a>
<a name="ln975">		    *scanpt++ = *rawpt;			/* G */</a>
<a name="ln976">		    *scanpt++ = *(rawpt+1);		/* R */</a>
<a name="ln977">		}</a>
<a name="ln978">	    } else {</a>
<a name="ln979">		/* R */</a>
<a name="ln980">		if ( i &lt; (WIDTH*(HEIGHT-1)) &amp;&amp; ((i % WIDTH) &lt; (WIDTH-1)) ) {</a>
<a name="ln981">		    *scanpt++ = (*(rawpt-WIDTH-1)+*(rawpt-WIDTH+1)+</a>
<a name="ln982">				 *(rawpt+WIDTH-1)+*(rawpt+WIDTH+1))/4;	/* B */</a>
<a name="ln983">		    *scanpt++ = (*(rawpt-1)+*(rawpt+1)+</a>
<a name="ln984">				 *(rawpt-WIDTH)+*(rawpt+WIDTH))/4;	/* G */</a>
<a name="ln985">		    *scanpt++ = *rawpt;					/* R */</a>
<a name="ln986">		} else {</a>
<a name="ln987">		    /* bottom line or right column */</a>
<a name="ln988">		    *scanpt++ = *(rawpt-WIDTH-1);		/* B */</a>
<a name="ln989">		    *scanpt++ = (*(rawpt-1)+*(rawpt-WIDTH))/2;	/* G */</a>
<a name="ln990">		    *scanpt++ = *rawpt;				/* R */</a>
<a name="ln991">		}</a>
<a name="ln992">	    }</a>
<a name="ln993">	}</a>
<a name="ln994">	rawpt++;</a>
<a name="ln995">	scanpt++;</a>
<a name="ln996">    }</a>
<a name="ln997"> </a>
<a name="ln998">}</a>

</code></pre>
<div class="balloon" rel="640"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'w * h' operator to the 'size_t' type, not the result.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

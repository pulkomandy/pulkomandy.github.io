
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>BrowserWindow.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (C) 2007 Andrea Anzani &lt;andrea.anzani@gmail.com&gt;</a>
<a name="ln3"> * Copyright (C) 2007, 2010 Ryan Leavengood &lt;leavengood@gmail.com&gt;</a>
<a name="ln4"> * Copyright (C) 2009 Maxime Simon &lt;simon.maxime@gmail.com&gt;</a>
<a name="ln5"> * Copyright (C) 2010 Stephan Aßmus &lt;superstippi@gmx.de&gt;</a>
<a name="ln6"> * Copyright (C) 2010 Michael Lotz &lt;mmlr@mlotz.ch&gt;</a>
<a name="ln7"> * Copyright (C) 2010 Rene Gollent &lt;rene@gollent.com&gt;</a>
<a name="ln8"> * Copyright 2013-2015 Haiku, Inc. All rights reserved.</a>
<a name="ln9"> *</a>
<a name="ln10"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln11"> * modification, are permitted provided that the following conditions</a>
<a name="ln12"> * are met:</a>
<a name="ln13"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln14"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln15"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln16"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln17"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln18"> *</a>
<a name="ln19"> * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY</a>
<a name="ln20"> * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln21"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</a>
<a name="ln22"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR</a>
<a name="ln23"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</a>
<a name="ln24"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</a>
<a name="ln25"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</a>
<a name="ln26"> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY</a>
<a name="ln27"> * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln28"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln29"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln30"> */</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;BrowserWindow.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;Alert.h&gt;</a>
<a name="ln35">#include &lt;Application.h&gt;</a>
<a name="ln36">#include &lt;Bitmap.h&gt;</a>
<a name="ln37">#include &lt;Button.h&gt;</a>
<a name="ln38">#include &lt;Catalog.h&gt;</a>
<a name="ln39">#include &lt;CheckBox.h&gt;</a>
<a name="ln40">#include &lt;Clipboard.h&gt;</a>
<a name="ln41">#include &lt;ControlLook.h&gt;</a>
<a name="ln42">#include &lt;Debug.h&gt;</a>
<a name="ln43">#include &lt;Directory.h&gt;</a>
<a name="ln44">#include &lt;Entry.h&gt;</a>
<a name="ln45">#include &lt;File.h&gt;</a>
<a name="ln46">#include &lt;FilePanel.h&gt;</a>
<a name="ln47">#include &lt;FindDirectory.h&gt;</a>
<a name="ln48">#include &lt;GridLayoutBuilder.h&gt;</a>
<a name="ln49">#include &lt;GroupLayout.h&gt;</a>
<a name="ln50">#include &lt;GroupLayoutBuilder.h&gt;</a>
<a name="ln51">#include &lt;IconMenuItem.h&gt;</a>
<a name="ln52">#include &lt;Keymap.h&gt;</a>
<a name="ln53">#include &lt;LayoutBuilder.h&gt;</a>
<a name="ln54">#include &lt;Locale.h&gt;</a>
<a name="ln55">#include &lt;ObjectList.h&gt;</a>
<a name="ln56">#include &lt;MenuBar.h&gt;</a>
<a name="ln57">#include &lt;MenuItem.h&gt;</a>
<a name="ln58">#include &lt;MessageRunner.h&gt;</a>
<a name="ln59">#include &lt;NodeInfo.h&gt;</a>
<a name="ln60">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln61">#include &lt;Path.h&gt;</a>
<a name="ln62">#include &lt;Roster.h&gt;</a>
<a name="ln63">#include &lt;Screen.h&gt;</a>
<a name="ln64">#include &lt;SeparatorView.h&gt;</a>
<a name="ln65">#include &lt;Size.h&gt;</a>
<a name="ln66">#include &lt;SpaceLayoutItem.h&gt;</a>
<a name="ln67">#include &lt;StatusBar.h&gt;</a>
<a name="ln68">#include &lt;StringView.h&gt;</a>
<a name="ln69">#include &lt;TextControl.h&gt;</a>
<a name="ln70">#include &lt;UnicodeChar.h&gt;</a>
<a name="ln71">#include &lt;Url.h&gt;</a>
<a name="ln72"> </a>
<a name="ln73">#include &lt;map&gt;</a>
<a name="ln74">#include &lt;stdio.h&gt;</a>
<a name="ln75"> </a>
<a name="ln76">#include &quot;AuthenticationPanel.h&quot;</a>
<a name="ln77">#include &quot;BaseURL.h&quot;</a>
<a name="ln78">#include &quot;BitmapButton.h&quot;</a>
<a name="ln79">#include &quot;BookmarkBar.h&quot;</a>
<a name="ln80">#include &quot;BrowserApp.h&quot;</a>
<a name="ln81">#include &quot;BrowsingHistory.h&quot;</a>
<a name="ln82">#include &quot;CredentialsStorage.h&quot;</a>
<a name="ln83">#include &quot;IconButton.h&quot;</a>
<a name="ln84">#include &quot;NavMenu.h&quot;</a>
<a name="ln85">#include &quot;SettingsKeys.h&quot;</a>
<a name="ln86">#include &quot;SettingsMessage.h&quot;</a>
<a name="ln87">#include &quot;TabManager.h&quot;</a>
<a name="ln88">#include &quot;URLInputGroup.h&quot;</a>
<a name="ln89">#include &quot;WebPage.h&quot;</a>
<a name="ln90">#include &quot;WebView.h&quot;</a>
<a name="ln91">#include &quot;WebViewConstants.h&quot;</a>
<a name="ln92">#include &quot;WindowIcon.h&quot;</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln96">#define B_TRANSLATION_CONTEXT &quot;WebPositive Window&quot;</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">enum {</a>
<a name="ln100">	OPEN_LOCATION								= 'open',</a>
<a name="ln101">	SAVE_PAGE									= 'save',</a>
<a name="ln102">	GO_BACK										= 'goba',</a>
<a name="ln103">	GO_FORWARD									= 'gofo',</a>
<a name="ln104">	STOP										= 'stop',</a>
<a name="ln105">	HOME										= 'home',</a>
<a name="ln106">	GOTO_URL									= 'goul',</a>
<a name="ln107">	RELOAD										= 'reld',</a>
<a name="ln108">	SHOW_HIDE_BOOKMARK_BAR						= 'shbb',</a>
<a name="ln109">	CLEAR_HISTORY								= 'clhs',</a>
<a name="ln110"> </a>
<a name="ln111">	CREATE_BOOKMARK								= 'crbm',</a>
<a name="ln112">	SHOW_BOOKMARKS								= 'shbm',</a>
<a name="ln113"> </a>
<a name="ln114">	ZOOM_FACTOR_INCREASE						= 'zfin',</a>
<a name="ln115">	ZOOM_FACTOR_DECREASE						= 'zfdc',</a>
<a name="ln116">	ZOOM_FACTOR_RESET							= 'zfrs',</a>
<a name="ln117">	ZOOM_TEXT_ONLY								= 'zfto',</a>
<a name="ln118"> </a>
<a name="ln119">	TOGGLE_FULLSCREEN							= 'tgfs',</a>
<a name="ln120">	TOGGLE_AUTO_HIDE_INTERFACE_IN_FULLSCREEN	= 'tgah',</a>
<a name="ln121">	CHECK_AUTO_HIDE_INTERFACE					= 'cahi',</a>
<a name="ln122"> </a>
<a name="ln123">	SHOW_PAGE_SOURCE							= 'spgs',</a>
<a name="ln124"> </a>
<a name="ln125">	EDIT_SHOW_FIND_GROUP						= 'sfnd',</a>
<a name="ln126">	EDIT_HIDE_FIND_GROUP						= 'hfnd',</a>
<a name="ln127">	EDIT_FIND_NEXT								= 'fndn',</a>
<a name="ln128">	EDIT_FIND_PREVIOUS							= 'fndp',</a>
<a name="ln129">	FIND_TEXT_CHANGED							= 'ftxt',</a>
<a name="ln130"> </a>
<a name="ln131">	SELECT_TAB									= 'sltb',</a>
<a name="ln132">};</a>
<a name="ln133"> </a>
<a name="ln134"> </a>
<a name="ln135">static const int32 kModifiers = B_SHIFT_KEY | B_COMMAND_KEY</a>
<a name="ln136">	| B_CONTROL_KEY | B_OPTION_KEY | B_MENU_KEY;</a>
<a name="ln137"> </a>
<a name="ln138"> </a>
<a name="ln139">static const char* kHandledProtocols[] = {</a>
<a name="ln140">	&quot;http&quot;,</a>
<a name="ln141">	&quot;https&quot;,</a>
<a name="ln142">	&quot;file&quot;,</a>
<a name="ln143">	&quot;about&quot;,</a>
<a name="ln144">	&quot;data&quot;,</a>
<a name="ln145">	&quot;gopher&quot;</a>
<a name="ln146">};</a>
<a name="ln147"> </a>
<a name="ln148"> </a>
<a name="ln149">static BLayoutItem*</a>
<a name="ln150">layoutItemFor(BView* view)</a>
<a name="ln151">{</a>
<a name="ln152">	BLayout* layout = view-&gt;Parent()-&gt;GetLayout();</a>
<a name="ln153">	int32 index = layout-&gt;IndexOfView(view);</a>
<a name="ln154">	return layout-&gt;ItemAt(index);</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157"> </a>
<a name="ln158">class BookmarkMenu : public BNavMenu {</a>
<a name="ln159">public:</a>
<a name="ln160">	BookmarkMenu(const char* title, BHandler* target, const entry_ref* navDir)</a>
<a name="ln161">		:</a>
<a name="ln162">		BNavMenu(title, B_REFS_RECEIVED, target)</a>
<a name="ln163">	{</a>
<a name="ln164">		// Add these items here already, so the shortcuts work even when</a>
<a name="ln165">		// the menu has never been opened yet.</a>
<a name="ln166">		_AddStaticItems();</a>
<a name="ln167"> </a>
<a name="ln168">		SetNavDir(navDir);</a>
<a name="ln169">	}</a>
<a name="ln170"> </a>
<a name="ln171">	virtual void AttachedToWindow()</a>
<a name="ln172">	{</a>
<a name="ln173">		RemoveItems(0, CountItems(), true);</a>
<a name="ln174">		ForceRebuild();</a>
<a name="ln175">		BNavMenu::AttachedToWindow();</a>
<a name="ln176">		if (CountItems() &gt; 0)</a>
<a name="ln177">			AddItem(new BSeparatorItem(), 0);</a>
<a name="ln178">		_AddStaticItems();</a>
<a name="ln179">		DoLayout();</a>
<a name="ln180">	}</a>
<a name="ln181"> </a>
<a name="ln182">private:</a>
<a name="ln183">	void _AddStaticItems()</a>
<a name="ln184">	{</a>
<a name="ln185">		AddItem(new BMenuItem(B_TRANSLATE(&quot;Manage bookmarks&quot;),</a>
<a name="ln186">			new BMessage(SHOW_BOOKMARKS), 'M'), 0);</a>
<a name="ln187">		AddItem(new BMenuItem(B_TRANSLATE(&quot;Bookmark this page&quot;),</a>
<a name="ln188">			new BMessage(CREATE_BOOKMARK), 'B'), 0);</a>
<a name="ln189">	}</a>
<a name="ln190">};</a>
<a name="ln191"> </a>
<a name="ln192"> </a>
<a name="ln193">class PageUserData : public BWebView::UserData {</a>
<a name="ln194">public:</a>
<a name="ln195">	PageUserData(BView* focusedView)</a>
<a name="ln196">		:</a>
<a name="ln197">		fFocusedView(focusedView),</a>
<a name="ln198">		fPageIcon(NULL),</a>
<a name="ln199">		fURLInputSelectionStart(-1),</a>
<a name="ln200">		fURLInputSelectionEnd(-1)</a>
<a name="ln201">	{</a>
<a name="ln202">	}</a>
<a name="ln203"> </a>
<a name="ln204">	~PageUserData()</a>
<a name="ln205">	{</a>
<a name="ln206">		delete fPageIcon;</a>
<a name="ln207">	}</a>
<a name="ln208"> </a>
<a name="ln209">	void SetFocusedView(BView* focusedView)</a>
<a name="ln210">	{</a>
<a name="ln211">		fFocusedView = focusedView;</a>
<a name="ln212">	}</a>
<a name="ln213"> </a>
<a name="ln214">	BView* FocusedView() const</a>
<a name="ln215">	{</a>
<a name="ln216">		return fFocusedView;</a>
<a name="ln217">	}</a>
<a name="ln218"> </a>
<a name="ln219">	void SetPageIcon(const BBitmap* icon)</a>
<a name="ln220">	{</a>
<a name="ln221">		delete fPageIcon;</a>
<a name="ln222">		if (icon)</a>
<a name="ln223">			fPageIcon = new BBitmap(icon);</a>
<a name="ln224">		else</a>
<a name="ln225">			fPageIcon = NULL;</a>
<a name="ln226">	}</a>
<a name="ln227"> </a>
<a name="ln228">	const BBitmap* PageIcon() const</a>
<a name="ln229">	{</a>
<a name="ln230">		return fPageIcon;</a>
<a name="ln231">	}</a>
<a name="ln232"> </a>
<a name="ln233">	void SetURLInputContents(const char* text)</a>
<a name="ln234">	{</a>
<a name="ln235">		fURLInputContents = text;</a>
<a name="ln236">	}</a>
<a name="ln237"> </a>
<a name="ln238">	const BString&amp; URLInputContents() const</a>
<a name="ln239">	{</a>
<a name="ln240">		return fURLInputContents;</a>
<a name="ln241">	}</a>
<a name="ln242"> </a>
<a name="ln243">	void SetURLInputSelection(int32 selectionStart, int32 selectionEnd)</a>
<a name="ln244">	{</a>
<a name="ln245">		fURLInputSelectionStart = selectionStart;</a>
<a name="ln246">		fURLInputSelectionEnd = selectionEnd;</a>
<a name="ln247">	}</a>
<a name="ln248"> </a>
<a name="ln249">	int32 URLInputSelectionStart() const</a>
<a name="ln250">	{</a>
<a name="ln251">		return fURLInputSelectionStart;</a>
<a name="ln252">	}</a>
<a name="ln253"> </a>
<a name="ln254">	int32 URLInputSelectionEnd() const</a>
<a name="ln255">	{</a>
<a name="ln256">		return fURLInputSelectionEnd;</a>
<a name="ln257">	}</a>
<a name="ln258"> </a>
<a name="ln259">private:</a>
<a name="ln260">	BView*		fFocusedView;</a>
<a name="ln261">	BBitmap*	fPageIcon;</a>
<a name="ln262">	BString		fURLInputContents;</a>
<a name="ln263">	int32		fURLInputSelectionStart;</a>
<a name="ln264">	int32		fURLInputSelectionEnd;</a>
<a name="ln265">};</a>
<a name="ln266"> </a>
<a name="ln267"> </a>
<a name="ln268">class CloseButton : public BButton {</a>
<a name="ln269">public:</a>
<a name="ln270">	CloseButton(BMessage* message)</a>
<a name="ln271">		:</a>
<a name="ln272">		BButton(&quot;close button&quot;, NULL, message),</a>
<a name="ln273">		fOverCloseRect(false)</a>
<a name="ln274">	{</a>
<a name="ln275">		// Button is 16x16 regardless of font size</a>
<a name="ln276">		SetExplicitMinSize(BSize(15, 15));</a>
<a name="ln277">		SetExplicitMaxSize(BSize(15, 15));</a>
<a name="ln278">	}</a>
<a name="ln279"> </a>
<a name="ln280">	virtual void Draw(BRect updateRect)</a>
<a name="ln281">	{</a>
<a name="ln282">		BRect frame = Bounds();</a>
<a name="ln283">		BRect closeRect(frame.InsetByCopy(4, 4));</a>
<a name="ln284">		rgb_color base = ui_color(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln285">		float tint = B_DARKEN_1_TINT;</a>
<a name="ln286"> </a>
<a name="ln287">		if (fOverCloseRect)</a>
<a name="ln288">			tint *= 1.4;</a>
<a name="ln289">		else</a>
<a name="ln290">			tint *= 1.2;</a>
<a name="ln291"> </a>
<a name="ln292">		if (Value() == B_CONTROL_ON &amp;&amp; fOverCloseRect) {</a>
<a name="ln293">			// Draw the button frame</a>
<a name="ln294">			be_control_look-&gt;DrawButtonFrame(this, frame, updateRect,</a>
<a name="ln295">				base, base, BControlLook::B_ACTIVATED</a>
<a name="ln296">					| BControlLook::B_BLEND_FRAME);</a>
<a name="ln297">			be_control_look-&gt;DrawButtonBackground(this, frame,</a>
<a name="ln298">				updateRect, base, BControlLook::B_ACTIVATED);</a>
<a name="ln299">			closeRect.OffsetBy(1, 1);</a>
<a name="ln300">			tint *= 1.2;</a>
<a name="ln301">		} else {</a>
<a name="ln302">			SetHighColor(base);</a>
<a name="ln303">			FillRect(updateRect);</a>
<a name="ln304">		}</a>
<a name="ln305"> </a>
<a name="ln306">		// Draw the ×</a>
<a name="ln307">		base = tint_color(base, tint);</a>
<a name="ln308">		SetHighColor(base);</a>
<a name="ln309">		SetPenSize(2);</a>
<a name="ln310">		StrokeLine(closeRect.LeftTop(), closeRect.RightBottom());</a>
<a name="ln311">		StrokeLine(closeRect.LeftBottom(), closeRect.RightTop());</a>
<a name="ln312">		SetPenSize(1);</a>
<a name="ln313">	}</a>
<a name="ln314"> </a>
<a name="ln315">	virtual void MouseMoved(BPoint where, uint32 transit,</a>
<a name="ln316">		const BMessage* dragMessage)</a>
<a name="ln317">	{</a>
<a name="ln318">		switch (transit) {</a>
<a name="ln319">			case B_ENTERED_VIEW:</a>
<a name="ln320">				fOverCloseRect = true;</a>
<a name="ln321">				Invalidate();</a>
<a name="ln322">				break;</a>
<a name="ln323">			case B_EXITED_VIEW:</a>
<a name="ln324">				fOverCloseRect = false;</a>
<a name="ln325">				Invalidate();</a>
<a name="ln326">				break;</a>
<a name="ln327">			case B_INSIDE_VIEW:</a>
<a name="ln328">				fOverCloseRect = true;</a>
<a name="ln329">				break;</a>
<a name="ln330">			case B_OUTSIDE_VIEW:</a>
<a name="ln331">				fOverCloseRect = false;</a>
<a name="ln332">				break;</a>
<a name="ln333">		}</a>
<a name="ln334"> </a>
<a name="ln335">		BButton::MouseMoved(where, transit, dragMessage);</a>
<a name="ln336">	}</a>
<a name="ln337"> </a>
<a name="ln338">private:</a>
<a name="ln339">	bool fOverCloseRect;</a>
<a name="ln340">};</a>
<a name="ln341"> </a>
<a name="ln342"> </a>
<a name="ln343">// #pragma mark - BrowserWindow</a>
<a name="ln344"> </a>
<a name="ln345"> </a>
<a name="ln346">BrowserWindow::BrowserWindow(BRect frame, SettingsMessage* appSettings,</a>
<a name="ln347">		const BString&amp; url, BUrlContext* context, uint32 interfaceElements,</a>
<a name="ln348">		BWebView* webView)</a>
<a name="ln349">	:</a>
<a name="ln350">	BWebWindow(frame, kApplicationName,</a>
<a name="ln351">		B_DOCUMENT_WINDOW_LOOK, B_NORMAL_WINDOW_FEEL,</a>
<a name="ln352">		B_AUTO_UPDATE_SIZE_LIMITS | B_ASYNCHRONOUS_CONTROLS),</a>
<a name="ln353">	fIsFullscreen(false),</a>
<a name="ln354">	fInterfaceVisible(false),</a>
<a name="ln355">	fMenusRunning(false),</a>
<a name="ln356">	fPulseRunner(NULL),</a>
<a name="ln357">	fVisibleInterfaceElements(interfaceElements),</a>
<a name="ln358">	fContext(context),</a>
<a name="ln359">	fAppSettings(appSettings),</a>
<a name="ln360">	fZoomTextOnly(true),</a>
<a name="ln361">	fShowTabsIfSinglePageOpen(true),</a>
<a name="ln362">	fAutoHideInterfaceInFullscreenMode(false),</a>
<a name="ln363">	fAutoHidePointer(false),</a>
<a name="ln364">	fBookmarkBar(NULL)</a>
<a name="ln365">{</a>
<a name="ln366">	// Begin listening to settings changes and read some current values.</a>
<a name="ln367">	fAppSettings-&gt;AddListener(BMessenger(this));</a>
<a name="ln368">//	fZoomTextOnly = fAppSettings-&gt;GetValue(&quot;zoom text only&quot;, fZoomTextOnly);</a>
<a name="ln369">	fShowTabsIfSinglePageOpen = fAppSettings-&gt;GetValue(</a>
<a name="ln370">		kSettingsKeyShowTabsIfSinglePageOpen, fShowTabsIfSinglePageOpen);</a>
<a name="ln371"> </a>
<a name="ln372">	fAutoHidePointer = fAppSettings-&gt;GetValue(kSettingsKeyAutoHidePointer,</a>
<a name="ln373">		fAutoHidePointer);</a>
<a name="ln374"> </a>
<a name="ln375">	fNewWindowPolicy = fAppSettings-&gt;GetValue(kSettingsKeyNewWindowPolicy,</a>
<a name="ln376">		(uint32)OpenStartPage);</a>
<a name="ln377">	fNewTabPolicy = fAppSettings-&gt;GetValue(kSettingsKeyNewTabPolicy,</a>
<a name="ln378">		(uint32)OpenBlankPage);</a>
<a name="ln379">	fStartPageURL = fAppSettings-&gt;GetValue(kSettingsKeyStartPageURL,</a>
<a name="ln380">		kDefaultStartPageURL);</a>
<a name="ln381">	fSearchPageURL = fAppSettings-&gt;GetValue(kSettingsKeySearchPageURL,</a>
<a name="ln382">		kDefaultSearchPageURL);</a>
<a name="ln383"> </a>
<a name="ln384">	// Create the interface elements</a>
<a name="ln385">	BMessage* newTabMessage = new BMessage(NEW_TAB);</a>
<a name="ln386">	newTabMessage-&gt;AddString(&quot;url&quot;, &quot;&quot;);</a>
<a name="ln387">	newTabMessage-&gt;AddPointer(&quot;window&quot;, this);</a>
<a name="ln388">	newTabMessage-&gt;AddBool(&quot;select&quot;, true);</a>
<a name="ln389">	fTabManager = new TabManager(BMessenger(this), newTabMessage);</a>
<a name="ln390"> </a>
<a name="ln391">	// Menu</a>
<a name="ln392">#if INTEGRATE_MENU_INTO_TAB_BAR</a>
<a name="ln393">	BMenu* mainMenu = fTabManager-&gt;Menu();</a>
<a name="ln394">#else</a>
<a name="ln395">	BMenu* mainMenu = new BMenuBar(&quot;Main menu&quot;);</a>
<a name="ln396">#endif</a>
<a name="ln397">	BMenu* menu = new BMenu(B_TRANSLATE(&quot;Window&quot;));</a>
<a name="ln398">	BMessage* newWindowMessage = new BMessage(NEW_WINDOW);</a>
<a name="ln399">	newWindowMessage-&gt;AddString(&quot;url&quot;, &quot;&quot;);</a>
<a name="ln400">	BMenuItem* newItem = new BMenuItem(B_TRANSLATE(&quot;New window&quot;),</a>
<a name="ln401">		newWindowMessage, 'N');</a>
<a name="ln402">	menu-&gt;AddItem(newItem);</a>
<a name="ln403">	newItem-&gt;SetTarget(be_app);</a>
<a name="ln404">	newItem = new BMenuItem(B_TRANSLATE(&quot;New tab&quot;),</a>
<a name="ln405">		new BMessage(*newTabMessage), 'T');</a>
<a name="ln406">	menu-&gt;AddItem(newItem);</a>
<a name="ln407">	newItem-&gt;SetTarget(be_app);</a>
<a name="ln408">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Open location&quot;),</a>
<a name="ln409">		new BMessage(OPEN_LOCATION), 'L'));</a>
<a name="ln410">	menu-&gt;AddSeparatorItem();</a>
<a name="ln411">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Close window&quot;),</a>
<a name="ln412">		new BMessage(B_QUIT_REQUESTED), 'W', B_SHIFT_KEY));</a>
<a name="ln413">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Close tab&quot;),</a>
<a name="ln414">		new BMessage(CLOSE_TAB), 'W'));</a>
<a name="ln415">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Save page as&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln416">		new BMessage(SAVE_PAGE), 'S'));</a>
<a name="ln417">	menu-&gt;AddSeparatorItem();</a>
<a name="ln418">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Downloads&quot;),</a>
<a name="ln419">		new BMessage(SHOW_DOWNLOAD_WINDOW), 'D'));</a>
<a name="ln420">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Settings&quot;),</a>
<a name="ln421">		new BMessage(SHOW_SETTINGS_WINDOW)));</a>
<a name="ln422">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Cookie manager&quot;),</a>
<a name="ln423">		new BMessage(SHOW_COOKIE_WINDOW)));</a>
<a name="ln424">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Script console&quot;),</a>
<a name="ln425">		new BMessage(SHOW_CONSOLE_WINDOW)));</a>
<a name="ln426">	BMenuItem* aboutItem = new BMenuItem(B_TRANSLATE(&quot;About&quot;),</a>
<a name="ln427">		new BMessage(B_ABOUT_REQUESTED));</a>
<a name="ln428">	menu-&gt;AddItem(aboutItem);</a>
<a name="ln429">	aboutItem-&gt;SetTarget(be_app);</a>
<a name="ln430">	menu-&gt;AddSeparatorItem();</a>
<a name="ln431">	BMenuItem* quitItem = new BMenuItem(B_TRANSLATE(&quot;Quit&quot;),</a>
<a name="ln432">		new BMessage(B_QUIT_REQUESTED), 'Q');</a>
<a name="ln433">	menu-&gt;AddItem(quitItem);</a>
<a name="ln434">	quitItem-&gt;SetTarget(be_app);</a>
<a name="ln435">	mainMenu-&gt;AddItem(menu);</a>
<a name="ln436"> </a>
<a name="ln437">	menu = new BMenu(B_TRANSLATE(&quot;Edit&quot;));</a>
<a name="ln438">	menu-&gt;AddItem(fCutMenuItem = new BMenuItem(B_TRANSLATE(&quot;Cut&quot;),</a>
<a name="ln439">		new BMessage(B_CUT), 'X'));</a>
<a name="ln440">	menu-&gt;AddItem(fCopyMenuItem = new BMenuItem(B_TRANSLATE(&quot;Copy&quot;),</a>
<a name="ln441">		new BMessage(B_COPY), 'C'));</a>
<a name="ln442">	menu-&gt;AddItem(fPasteMenuItem = new BMenuItem(B_TRANSLATE(&quot;Paste&quot;),</a>
<a name="ln443">		new BMessage(B_PASTE), 'V'));</a>
<a name="ln444">	menu-&gt;AddSeparatorItem();</a>
<a name="ln445">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Find&quot;),</a>
<a name="ln446">		new BMessage(EDIT_SHOW_FIND_GROUP), 'F'));</a>
<a name="ln447">	menu-&gt;AddItem(fFindPreviousMenuItem</a>
<a name="ln448">		= new BMenuItem(B_TRANSLATE(&quot;Find previous&quot;),</a>
<a name="ln449">		new BMessage(EDIT_FIND_PREVIOUS), 'G', B_SHIFT_KEY));</a>
<a name="ln450">	menu-&gt;AddItem(fFindNextMenuItem = new BMenuItem(B_TRANSLATE(&quot;Find next&quot;),</a>
<a name="ln451">		new BMessage(EDIT_FIND_NEXT), 'G'));</a>
<a name="ln452">	mainMenu-&gt;AddItem(menu);</a>
<a name="ln453">	fFindPreviousMenuItem-&gt;SetEnabled(false);</a>
<a name="ln454">	fFindNextMenuItem-&gt;SetEnabled(false);</a>
<a name="ln455"> </a>
<a name="ln456">	menu = new BMenu(B_TRANSLATE(&quot;View&quot;));</a>
<a name="ln457">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Reload&quot;), new BMessage(RELOAD),</a>
<a name="ln458">		'R'));</a>
<a name="ln459">	// the label will be replaced with the appropriate text later on</a>
<a name="ln460">	fBookmarkBarMenuItem = new BMenuItem(B_TRANSLATE(&quot;Show bookmark bar&quot;),</a>
<a name="ln461">		new BMessage(SHOW_HIDE_BOOKMARK_BAR));</a>
<a name="ln462">	menu-&gt;AddItem(fBookmarkBarMenuItem);</a>
<a name="ln463">	menu-&gt;AddSeparatorItem();</a>
<a name="ln464">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Increase size&quot;),</a>
<a name="ln465">		new BMessage(ZOOM_FACTOR_INCREASE), '+'));</a>
<a name="ln466">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Decrease size&quot;),</a>
<a name="ln467">		new BMessage(ZOOM_FACTOR_DECREASE), '-'));</a>
<a name="ln468">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Reset size&quot;),</a>
<a name="ln469">		new BMessage(ZOOM_FACTOR_RESET), '0'));</a>
<a name="ln470">	fZoomTextOnlyMenuItem = new BMenuItem(B_TRANSLATE(&quot;Zoom text only&quot;),</a>
<a name="ln471">		new BMessage(ZOOM_TEXT_ONLY));</a>
<a name="ln472">	fZoomTextOnlyMenuItem-&gt;SetMarked(fZoomTextOnly);</a>
<a name="ln473">	menu-&gt;AddItem(fZoomTextOnlyMenuItem);</a>
<a name="ln474"> </a>
<a name="ln475">	menu-&gt;AddSeparatorItem();</a>
<a name="ln476">	fFullscreenItem = new BMenuItem(B_TRANSLATE(&quot;Full screen&quot;),</a>
<a name="ln477">		new BMessage(TOGGLE_FULLSCREEN), B_RETURN);</a>
<a name="ln478">	menu-&gt;AddItem(fFullscreenItem);</a>
<a name="ln479">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Page source&quot;),</a>
<a name="ln480">		new BMessage(SHOW_PAGE_SOURCE), 'U'));</a>
<a name="ln481">	mainMenu-&gt;AddItem(menu);</a>
<a name="ln482"> </a>
<a name="ln483">	fHistoryMenu = new BMenu(B_TRANSLATE(&quot;History&quot;));</a>
<a name="ln484">	fHistoryMenu-&gt;AddItem(fBackMenuItem = new BMenuItem(B_TRANSLATE(&quot;Back&quot;),</a>
<a name="ln485">		new BMessage(GO_BACK), B_LEFT_ARROW));</a>
<a name="ln486">	fHistoryMenu-&gt;AddItem(fForwardMenuItem</a>
<a name="ln487">		= new BMenuItem(B_TRANSLATE(&quot;Forward&quot;), new BMessage(GO_FORWARD),</a>
<a name="ln488">		B_RIGHT_ARROW));</a>
<a name="ln489">	fHistoryMenu-&gt;AddSeparatorItem();</a>
<a name="ln490">	fHistoryMenuFixedItemCount = fHistoryMenu-&gt;CountItems();</a>
<a name="ln491">	mainMenu-&gt;AddItem(fHistoryMenu);</a>
<a name="ln492"> </a>
<a name="ln493">	BPath bookmarkPath;</a>
<a name="ln494">	entry_ref bookmarkRef;</a>
<a name="ln495">	if (_BookmarkPath(bookmarkPath) == B_OK</a>
<a name="ln496">		&amp;&amp; get_ref_for_path(bookmarkPath.Path(), &amp;bookmarkRef) == B_OK) {</a>
<a name="ln497">		BMenu* bookmarkMenu</a>
<a name="ln498">			= new BookmarkMenu(B_TRANSLATE(&quot;Bookmarks&quot;), this, &amp;bookmarkRef);</a>
<a name="ln499">		mainMenu-&gt;AddItem(bookmarkMenu);</a>
<a name="ln500"> </a>
<a name="ln501">		BDirectory barDir(&amp;bookmarkRef);</a>
<a name="ln502">		BEntry bookmarkBar(&amp;barDir, &quot;Bookmark bar&quot;);</a>
<a name="ln503">		entry_ref bookmarkBarRef;</a>
<a name="ln504">		// TODO we could also check if the folder is empty here.</a>
<a name="ln505">		if (bookmarkBar.Exists() &amp;&amp; bookmarkBar.GetRef(&amp;bookmarkBarRef)</a>
<a name="ln506">				== B_OK) {</a>
<a name="ln507">			fBookmarkBar = new BookmarkBar(&quot;Bookmarks&quot;, this, &amp;bookmarkBarRef);</a>
<a name="ln508">			fBookmarkBarMenuItem-&gt;SetEnabled(true);</a>
<a name="ln509">		} else</a>
<a name="ln510">			fBookmarkBarMenuItem-&gt;SetEnabled(false);</a>
<a name="ln511">	} else</a>
<a name="ln512">		fBookmarkBarMenuItem-&gt;SetEnabled(false);</a>
<a name="ln513"> </a>
<a name="ln514">	// Back, Forward, Stop &amp; Home buttons</a>
<a name="ln515">	fBackButton = new BIconButton(&quot;Back&quot;, NULL, new BMessage(GO_BACK));</a>
<a name="ln516">	fBackButton-&gt;SetIcon(201);</a>
<a name="ln517">	fBackButton-&gt;TrimIcon();</a>
<a name="ln518"> </a>
<a name="ln519">	fForwardButton = new BIconButton(&quot;Forward&quot;, NULL, new BMessage(GO_FORWARD));</a>
<a name="ln520">	fForwardButton-&gt;SetIcon(202);</a>
<a name="ln521">	fForwardButton-&gt;TrimIcon();</a>
<a name="ln522"> </a>
<a name="ln523">	fStopButton = new BIconButton(&quot;Stop&quot;, NULL, new BMessage(STOP));</a>
<a name="ln524">	fStopButton-&gt;SetIcon(204);</a>
<a name="ln525">	fStopButton-&gt;TrimIcon();</a>
<a name="ln526"> </a>
<a name="ln527">	fHomeButton = new BIconButton(&quot;Home&quot;, NULL, new BMessage(HOME));</a>
<a name="ln528">	fHomeButton-&gt;SetIcon(206);</a>
<a name="ln529">	fHomeButton-&gt;TrimIcon();</a>
<a name="ln530">	if (!fAppSettings-&gt;GetValue(kSettingsKeyShowHomeButton, true))</a>
<a name="ln531">		fHomeButton-&gt;Hide();</a>
<a name="ln532"> </a>
<a name="ln533">	// URL input group</a>
<a name="ln534">	fURLInputGroup = new URLInputGroup(new BMessage(GOTO_URL));</a>
<a name="ln535"> </a>
<a name="ln536">	// Status Bar</a>
<a name="ln537">	fStatusText = new BStringView(&quot;status&quot;, &quot;&quot;);</a>
<a name="ln538">	fStatusText-&gt;SetAlignment(B_ALIGN_LEFT);</a>
<a name="ln539">	fStatusText-&gt;SetExplicitMaxSize(BSize(B_SIZE_UNLIMITED, B_SIZE_UNSET));</a>
<a name="ln540">	fStatusText-&gt;SetExplicitMinSize(BSize(150, 12));</a>
<a name="ln541">		// Prevent the window from growing to fit a long status message...</a>
<a name="ln542">	BFont font(be_plain_font);</a>
<a name="ln543">	font.SetSize(ceilf(font.Size() * 0.8));</a>
<a name="ln544">	fStatusText-&gt;SetFont(&amp;font, B_FONT_SIZE);</a>
<a name="ln545"> </a>
<a name="ln546">	// Loading progress bar</a>
<a name="ln547">	fLoadingProgressBar = new BStatusBar(&quot;progress&quot;);</a>
<a name="ln548">	fLoadingProgressBar-&gt;SetMaxValue(100);</a>
<a name="ln549">	fLoadingProgressBar-&gt;Hide();</a>
<a name="ln550">	fLoadingProgressBar-&gt;SetBarHeight(12);</a>
<a name="ln551"> </a>
<a name="ln552">	const float kInsetSpacing = 3;</a>
<a name="ln553">	const float kElementSpacing = 5;</a>
<a name="ln554"> </a>
<a name="ln555">	// Find group</a>
<a name="ln556">	fFindCloseButton = new CloseButton(new BMessage(EDIT_HIDE_FIND_GROUP));</a>
<a name="ln557">	fFindTextControl = new BTextControl(&quot;find&quot;, B_TRANSLATE(&quot;Find:&quot;), &quot;&quot;, NULL);</a>
<a name="ln558">	fFindTextControl-&gt;SetModificationMessage(new BMessage(FIND_TEXT_CHANGED));</a>
<a name="ln559">	fFindPreviousButton = new BButton(B_TRANSLATE(&quot;Previous&quot;),</a>
<a name="ln560">		new BMessage(EDIT_FIND_PREVIOUS));</a>
<a name="ln561">	fFindPreviousButton-&gt;SetToolTip(</a>
<a name="ln562">		B_TRANSLATE_COMMENT(&quot;Find previous occurrence of search terms&quot;,</a>
<a name="ln563">			&quot;find bar previous button tooltip&quot;));</a>
<a name="ln564">	fFindNextButton = new BButton(B_TRANSLATE(&quot;Next&quot;),</a>
<a name="ln565">		new BMessage(EDIT_FIND_NEXT));</a>
<a name="ln566">	fFindNextButton-&gt;SetToolTip(</a>
<a name="ln567">		B_TRANSLATE_COMMENT(&quot;Find next occurrence of search terms&quot;,</a>
<a name="ln568">			&quot;find bar next button tooltip&quot;));</a>
<a name="ln569">	fFindCaseSensitiveCheckBox = new BCheckBox(B_TRANSLATE(&quot;Match case&quot;));</a>
<a name="ln570">	BGroupLayout* findGroup = BLayoutBuilder::Group&lt;&gt;(B_VERTICAL, 0.0)</a>
<a name="ln571">		.Add(new BSeparatorView(B_HORIZONTAL, B_PLAIN_BORDER))</a>
<a name="ln572">		.Add(BGroupLayoutBuilder(B_HORIZONTAL, B_USE_SMALL_SPACING)</a>
<a name="ln573">			.Add(fFindCloseButton)</a>
<a name="ln574">			.Add(fFindTextControl)</a>
<a name="ln575">			.Add(fFindPreviousButton)</a>
<a name="ln576">			.Add(fFindNextButton)</a>
<a name="ln577">			.Add(fFindCaseSensitiveCheckBox)</a>
<a name="ln578">			.SetInsets(kInsetSpacing, kInsetSpacing,</a>
<a name="ln579">				kInsetSpacing, kInsetSpacing)</a>
<a name="ln580">		)</a>
<a name="ln581">	;</a>
<a name="ln582"> </a>
<a name="ln583">	// Navigation group</a>
<a name="ln584">	BGroupLayout* navigationGroup = BLayoutBuilder::Group&lt;&gt;(B_VERTICAL, 0.0)</a>
<a name="ln585">		.Add(BLayoutBuilder::Group&lt;&gt;(B_HORIZONTAL, kElementSpacing)</a>
<a name="ln586">			.Add(fBackButton)</a>
<a name="ln587">			.Add(fForwardButton)</a>
<a name="ln588">			.Add(fStopButton)</a>
<a name="ln589">			.Add(fHomeButton)</a>
<a name="ln590">			.Add(fURLInputGroup)</a>
<a name="ln591">			.SetInsets(kInsetSpacing, kInsetSpacing, kInsetSpacing,</a>
<a name="ln592">				kInsetSpacing)</a>
<a name="ln593">		)</a>
<a name="ln594">		.Add(new BSeparatorView(B_HORIZONTAL, B_PLAIN_BORDER))</a>
<a name="ln595">	;</a>
<a name="ln596"> </a>
<a name="ln597">	// Status bar group</a>
<a name="ln598">	BGroupLayout* statusGroup = BLayoutBuilder::Group&lt;&gt;(B_VERTICAL, 0.0)</a>
<a name="ln599">		.Add(new BSeparatorView(B_HORIZONTAL, B_PLAIN_BORDER))</a>
<a name="ln600">		.Add(BLayoutBuilder::Group&lt;&gt;(B_HORIZONTAL, kElementSpacing)</a>
<a name="ln601">			.Add(fStatusText)</a>
<a name="ln602">			.Add(fLoadingProgressBar, 0.2)</a>
<a name="ln603">			.AddStrut(12 - kElementSpacing)</a>
<a name="ln604">			.SetInsets(kInsetSpacing, 0, kInsetSpacing, 0)</a>
<a name="ln605">		)</a>
<a name="ln606">	;</a>
<a name="ln607"> </a>
<a name="ln608">	BBitmapButton* toggleFullscreenButton = new BBitmapButton(kWindowIconBits,</a>
<a name="ln609">		kWindowIconWidth, kWindowIconHeight, kWindowIconFormat,</a>
<a name="ln610">		new BMessage(TOGGLE_FULLSCREEN));</a>
<a name="ln611">	toggleFullscreenButton-&gt;SetBackgroundMode(BBitmapButton::MENUBAR_BACKGROUND);</a>
<a name="ln612"> </a>
<a name="ln613">	BGroupLayout* menuBarGroup = BLayoutBuilder::Group&lt;&gt;(B_HORIZONTAL, 0.0)</a>
<a name="ln614">		.Add(mainMenu)</a>
<a name="ln615">		.Add(toggleFullscreenButton, 0.0f)</a>
<a name="ln616">	;</a>
<a name="ln617"> </a>
<a name="ln618">	if (fAppSettings-&gt;GetValue(kSettingsShowBookmarkBar, true))</a>
<a name="ln619">		_ShowBookmarkBar(true);</a>
<a name="ln620">	else</a>
<a name="ln621">		_ShowBookmarkBar(false);</a>
<a name="ln622"> </a>
<a name="ln623">	fSavePanel = new BFilePanel(B_SAVE_PANEL, new BMessenger(this), NULL, 0,</a>
<a name="ln624">		false);</a>
<a name="ln625"> </a>
<a name="ln626">	// Layout</a>
<a name="ln627">	BGroupView* topView = new BGroupView(B_VERTICAL, 0.0);</a>
<a name="ln628"> </a>
<a name="ln629">#if !INTEGRATE_MENU_INTO_TAB_BAR</a>
<a name="ln630">	topView-&gt;AddChild(menuBarGroup);</a>
<a name="ln631">#endif</a>
<a name="ln632">	topView-&gt;AddChild(fTabManager-&gt;TabGroup());</a>
<a name="ln633">	topView-&gt;AddChild(navigationGroup);</a>
<a name="ln634">	if (fBookmarkBar != NULL)</a>
<a name="ln635">		topView-&gt;AddChild(fBookmarkBar);</a>
<a name="ln636">	topView-&gt;AddChild(fTabManager-&gt;ContainerView());</a>
<a name="ln637">	topView-&gt;AddChild(findGroup);</a>
<a name="ln638">	topView-&gt;AddChild(statusGroup);</a>
<a name="ln639"> </a>
<a name="ln640">	AddChild(topView);</a>
<a name="ln641"> </a>
<a name="ln642">	fURLInputGroup-&gt;MakeFocus(true);</a>
<a name="ln643"> </a>
<a name="ln644">	fMenuGroup = menuBarGroup;</a>
<a name="ln645">	fTabGroup = fTabManager-&gt;TabGroup()-&gt;GetLayout();</a>
<a name="ln646">	fNavigationGroup = navigationGroup;</a>
<a name="ln647">	fFindGroup = findGroup;</a>
<a name="ln648">	fStatusGroup = statusGroup;</a>
<a name="ln649">	fToggleFullscreenButton = layoutItemFor(toggleFullscreenButton);</a>
<a name="ln650"> </a>
<a name="ln651">	fFindGroup-&gt;SetVisible(false);</a>
<a name="ln652">	fToggleFullscreenButton-&gt;SetVisible(false);</a>
<a name="ln653"> </a>
<a name="ln654">	CreateNewTab(url, true, webView);</a>
<a name="ln655">	_ShowInterface(true);</a>
<a name="ln656">	_SetAutoHideInterfaceInFullscreen(fAppSettings-&gt;GetValue(</a>
<a name="ln657">		kSettingsKeyAutoHideInterfaceInFullscreenMode,</a>
<a name="ln658">		fAutoHideInterfaceInFullscreenMode));</a>
<a name="ln659"> </a>
<a name="ln660">	AddShortcut('F', B_COMMAND_KEY | B_SHIFT_KEY,</a>
<a name="ln661">		new BMessage(EDIT_HIDE_FIND_GROUP));</a>
<a name="ln662">	// TODO: Should be a different shortcut, H is usually for Find selection.</a>
<a name="ln663">	AddShortcut('H', B_COMMAND_KEY,	new BMessage(HOME));</a>
<a name="ln664"> </a>
<a name="ln665">	// Add shortcuts to select a particular tab</a>
<a name="ln666">	for (int32 i = 1; i &lt;= 9; i++) {</a>
<a name="ln667">		BMessage* selectTab = new BMessage(SELECT_TAB);</a>
<a name="ln668">		selectTab-&gt;AddInt32(&quot;tab index&quot;, i - 1);</a>
<a name="ln669">		char numStr[2];</a>
<a name="ln670">		snprintf(numStr, sizeof(numStr), &quot;%d&quot;, (int) i);</a>
<a name="ln671">		AddShortcut(numStr[0], B_COMMAND_KEY, selectTab);</a>
<a name="ln672">	}</a>
<a name="ln673"> </a>
<a name="ln674">	BKeymap keymap;</a>
<a name="ln675">	keymap.SetToCurrent();</a>
<a name="ln676">	BObjectList&lt;const char&gt; unmodified(3, true);</a>
<a name="ln677">	if (keymap.GetModifiedCharacters(&quot;+&quot;, B_SHIFT_KEY, 0, &amp;unmodified)</a>
<a name="ln678">			== B_OK) {</a>
<a name="ln679">		int32 count = unmodified.CountItems();</a>
<a name="ln680">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln681">			uint32 key = BUnicodeChar::FromUTF8(unmodified.ItemAt(i));</a>
<a name="ln682">			if (!HasShortcut(key, 0)) {</a>
<a name="ln683">				// Add semantic zoom in shortcut, bug #7428</a>
<a name="ln684">				AddShortcut(key, B_COMMAND_KEY,</a>
<a name="ln685">					new BMessage(ZOOM_FACTOR_INCREASE));</a>
<a name="ln686">			}</a>
<a name="ln687">		}</a>
<a name="ln688">	}</a>
<a name="ln689">	unmodified.MakeEmpty();</a>
<a name="ln690"> </a>
<a name="ln691">	be_app-&gt;PostMessage(WINDOW_OPENED);</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694"> </a>
<a name="ln695">BrowserWindow::~BrowserWindow()</a>
<a name="ln696">{</a>
<a name="ln697">	fAppSettings-&gt;RemoveListener(BMessenger(this));</a>
<a name="ln698">	delete fTabManager;</a>
<a name="ln699">	delete fPulseRunner;</a>
<a name="ln700">	delete fSavePanel;</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703"> </a>
<a name="ln704">void</a>
<a name="ln705">BrowserWindow::DispatchMessage(BMessage* message, BHandler* target)</a>
<a name="ln706">{</a>
<a name="ln707">	const char* bytes;</a>
<a name="ln708">	int32 modifierKeys;</a>
<a name="ln709">	if ((message-&gt;what == B_KEY_DOWN || message-&gt;what == B_UNMAPPED_KEY_DOWN)</a>
<a name="ln710">		&amp;&amp; message-&gt;FindString(&quot;bytes&quot;, &amp;bytes) == B_OK</a>
<a name="ln711">		&amp;&amp; message-&gt;FindInt32(&quot;modifiers&quot;, &amp;modifierKeys) == B_OK) {</a>
<a name="ln712">		if (bytes[0] == B_FUNCTION_KEY) {</a>
<a name="ln713">			// Some function key Firefox compatibility</a>
<a name="ln714">			int32 key;</a>
<a name="ln715">			if (message-&gt;FindInt32(&quot;key&quot;, &amp;key) == B_OK) {</a>
<a name="ln716">				switch (key) {</a>
<a name="ln717">					case B_F5_KEY:</a>
<a name="ln718">						PostMessage(RELOAD);</a>
<a name="ln719">						break;</a>
<a name="ln720"> </a>
<a name="ln721">					case B_F11_KEY:</a>
<a name="ln722">						PostMessage(TOGGLE_FULLSCREEN);</a>
<a name="ln723">						break;</a>
<a name="ln724"> </a>
<a name="ln725">					default:</a>
<a name="ln726">						break;</a>
<a name="ln727">				}</a>
<a name="ln728">			}</a>
<a name="ln729">		} else if (target == fURLInputGroup-&gt;TextView()) {</a>
<a name="ln730">			// Handle B_RETURN in the URL text control. This is the easiest</a>
<a name="ln731">			// way to react *only* when the user presses the return key in the</a>
<a name="ln732">			// address bar, as opposed to trying to load whatever is in there</a>
<a name="ln733">			// when the text control just goes out of focus.</a>
<a name="ln734">			if (bytes[0] == B_RETURN) {</a>
<a name="ln735">				// Do it in such a way that the user sees the Go-button go down.</a>
<a name="ln736">				_InvokeButtonVisibly(fURLInputGroup-&gt;GoButton());</a>
<a name="ln737">				return;</a>
<a name="ln738">			} else if (bytes[0] == B_ESCAPE) {</a>
<a name="ln739">				// Replace edited text with the current URL.</a>
<a name="ln740">				fURLInputGroup-&gt;LockURLInput(false);</a>
<a name="ln741">				fURLInputGroup-&gt;SetText(CurrentWebView()-&gt;MainFrameURL());</a>
<a name="ln742">			}</a>
<a name="ln743">		} else if (target == fFindTextControl-&gt;TextView()) {</a>
<a name="ln744">			// Handle B_RETURN when the find text control has focus.</a>
<a name="ln745">			if (bytes[0] == B_RETURN) {</a>
<a name="ln746">				if ((modifierKeys &amp; B_SHIFT_KEY) != 0)</a>
<a name="ln747">					_InvokeButtonVisibly(fFindPreviousButton);</a>
<a name="ln748">				else</a>
<a name="ln749">					_InvokeButtonVisibly(fFindNextButton);</a>
<a name="ln750">				return;</a>
<a name="ln751">			} else if (bytes[0] == B_ESCAPE) {</a>
<a name="ln752">				_InvokeButtonVisibly(fFindCloseButton);</a>
<a name="ln753">				return;</a>
<a name="ln754">			}</a>
<a name="ln755">		} else if (bytes[0] == B_ESCAPE &amp;&amp; !fMenusRunning) {</a>
<a name="ln756">			if (modifierKeys == B_COMMAND_KEY)</a>
<a name="ln757">				_ShowInterface(true);</a>
<a name="ln758">			else {</a>
<a name="ln759">				// Default escape key behavior:</a>
<a name="ln760">				PostMessage(STOP);</a>
<a name="ln761">				return;</a>
<a name="ln762">			}</a>
<a name="ln763">		}</a>
<a name="ln764">	}</a>
<a name="ln765"> </a>
<a name="ln766">	if (message-&gt;what == B_MOUSE_MOVED || message-&gt;what == B_MOUSE_DOWN</a>
<a name="ln767">		|| message-&gt;what == B_MOUSE_UP) {</a>
<a name="ln768">		message-&gt;FindPoint(&quot;where&quot;, &amp;fLastMousePos);</a>
<a name="ln769">		if (message-&gt;FindInt64(&quot;when&quot;, &amp;fLastMouseMovedTime) != B_OK)</a>
<a name="ln770">			fLastMouseMovedTime = system_time();</a>
<a name="ln771">		_CheckAutoHideInterface();</a>
<a name="ln772">	}</a>
<a name="ln773"> </a>
<a name="ln774">	if (message-&gt;what == B_MOUSE_WHEEL_CHANGED) {</a>
<a name="ln775">		BPoint where;</a>
<a name="ln776">		uint32 buttons;</a>
<a name="ln777">		CurrentWebView()-&gt;GetMouse(&amp;where, &amp;buttons, false);</a>
<a name="ln778">		// Only do this when the mouse is over the web view</a>
<a name="ln779">		if (CurrentWebView()-&gt;Bounds().Contains(where)) {</a>
<a name="ln780">			// Zoom and unzoom text on Command + mouse wheel.</a>
<a name="ln781">			// This could of course (and maybe should be) implemented in the</a>
<a name="ln782">			// WebView, but there would need to be a way for the WebView to</a>
<a name="ln783">			// know the setting of the fZoomTextOnly member here. Plus other</a>
<a name="ln784">			// clients of the API may not want this feature.</a>
<a name="ln785">			if ((modifiers() &amp; B_COMMAND_KEY) != 0) {</a>
<a name="ln786">				float deltaY;</a>
<a name="ln787">				if (message-&gt;FindFloat(&quot;be:wheel_delta_y&quot;, &amp;deltaY) == B_OK) {</a>
<a name="ln788">					if (deltaY &lt; 0)</a>
<a name="ln789">						CurrentWebView()-&gt;IncreaseZoomFactor(fZoomTextOnly);</a>
<a name="ln790">					else</a>
<a name="ln791">						CurrentWebView()-&gt;DecreaseZoomFactor(fZoomTextOnly);</a>
<a name="ln792"> </a>
<a name="ln793">					return;</a>
<a name="ln794">				}</a>
<a name="ln795">			}</a>
<a name="ln796">		} else {</a>
<a name="ln797">			// Also don't scroll up and down if the mouse is not over the</a>
<a name="ln798">			// web view</a>
<a name="ln799">			return;</a>
<a name="ln800">		}</a>
<a name="ln801">	}</a>
<a name="ln802"> </a>
<a name="ln803">	BWebWindow::DispatchMessage(message, target);</a>
<a name="ln804">}</a>
<a name="ln805"> </a>
<a name="ln806"> </a>
<a name="ln807">void</a>
<a name="ln808">BrowserWindow::MessageReceived(BMessage* message)</a>
<a name="ln809">{</a>
<a name="ln810">	switch (message-&gt;what) {</a>
<a name="ln811">		case OPEN_LOCATION:</a>
<a name="ln812">			_ShowInterface(true);</a>
<a name="ln813">			if (fURLInputGroup-&gt;TextView()-&gt;IsFocus())</a>
<a name="ln814">				fURLInputGroup-&gt;TextView()-&gt;SelectAll();</a>
<a name="ln815">			else</a>
<a name="ln816">				fURLInputGroup-&gt;MakeFocus(true);</a>
<a name="ln817">			break;</a>
<a name="ln818"> </a>
<a name="ln819">		case RELOAD:</a>
<a name="ln820">			CurrentWebView()-&gt;Reload();</a>
<a name="ln821">			break;</a>
<a name="ln822"> </a>
<a name="ln823">		case SHOW_HIDE_BOOKMARK_BAR:</a>
<a name="ln824">			_ShowBookmarkBar(fBookmarkBar-&gt;IsHidden());</a>
<a name="ln825">			break;</a>
<a name="ln826"> </a>
<a name="ln827">		case GOTO_URL:</a>
<a name="ln828">		{</a>
<a name="ln829">			BString url;</a>
<a name="ln830">			if (message-&gt;FindString(&quot;url&quot;, &amp;url) != B_OK)</a>
<a name="ln831">				url = fURLInputGroup-&gt;Text();</a>
<a name="ln832"> </a>
<a name="ln833">			_SetPageIcon(CurrentWebView(), NULL);</a>
<a name="ln834">			_SmartURLHandler(url);</a>
<a name="ln835"> </a>
<a name="ln836">			break;</a>
<a name="ln837">		}</a>
<a name="ln838"> </a>
<a name="ln839">		case SAVE_PAGE:</a>
<a name="ln840">		{</a>
<a name="ln841">			fSavePanel-&gt;SetSaveText(CurrentWebView()-&gt;MainFrameTitle());</a>
<a name="ln842">			fSavePanel-&gt;Show();</a>
<a name="ln843">			break;</a>
<a name="ln844">		}</a>
<a name="ln845"> </a>
<a name="ln846">		case B_SAVE_REQUESTED:</a>
<a name="ln847">		{</a>
<a name="ln848">			entry_ref ref;</a>
<a name="ln849">			BString name;</a>
<a name="ln850"> </a>
<a name="ln851">			if (message-&gt;FindRef(&quot;directory&quot;, &amp;ref) == B_OK</a>
<a name="ln852">				&amp;&amp; message-&gt;FindString(&quot;name&quot;, &amp;name) == B_OK) {</a>
<a name="ln853">				BDirectory dir(&amp;ref);</a>
<a name="ln854">				BFile output(&amp;dir, name,</a>
<a name="ln855">					B_WRITE_ONLY | B_CREATE_FILE | B_ERASE_FILE);</a>
<a name="ln856">				CurrentWebView()-&gt;WebPage()-&gt;GetContentsAsMHTML(output);</a>
<a name="ln857">			}</a>
<a name="ln858"> </a>
<a name="ln859">			break;</a>
<a name="ln860">		}</a>
<a name="ln861"> </a>
<a name="ln862">		case GO_BACK:</a>
<a name="ln863">			CurrentWebView()-&gt;GoBack();</a>
<a name="ln864">			break;</a>
<a name="ln865"> </a>
<a name="ln866">		case GO_FORWARD:</a>
<a name="ln867">			CurrentWebView()-&gt;GoForward();</a>
<a name="ln868">			break;</a>
<a name="ln869"> </a>
<a name="ln870">		case STOP:</a>
<a name="ln871">			CurrentWebView()-&gt;StopLoading();</a>
<a name="ln872">			break;</a>
<a name="ln873"> </a>
<a name="ln874">		case HOME:</a>
<a name="ln875">			CurrentWebView()-&gt;LoadURL(fStartPageURL);</a>
<a name="ln876">			break;</a>
<a name="ln877"> </a>
<a name="ln878">		case CLEAR_HISTORY: {</a>
<a name="ln879">			BrowsingHistory* history = BrowsingHistory::DefaultInstance();</a>
<a name="ln880">			if (history-&gt;CountItems() == 0)</a>
<a name="ln881">				break;</a>
<a name="ln882">			BAlert* alert = new BAlert(B_TRANSLATE(&quot;Confirmation&quot;),</a>
<a name="ln883">				B_TRANSLATE(&quot;Do you really want to &quot;</a>
<a name="ln884">				&quot;clear the browsing history?&quot;), B_TRANSLATE(&quot;Clear&quot;),</a>
<a name="ln885">				B_TRANSLATE(&quot;Cancel&quot;));</a>
<a name="ln886">			alert-&gt;SetShortcut(1, B_ESCAPE);</a>
<a name="ln887"> </a>
<a name="ln888">			if (alert-&gt;Go() == 0)</a>
<a name="ln889">				history-&gt;Clear();</a>
<a name="ln890">			break;</a>
<a name="ln891">		}</a>
<a name="ln892"> </a>
<a name="ln893">		case CREATE_BOOKMARK:</a>
<a name="ln894">			_CreateBookmark();</a>
<a name="ln895">			break;</a>
<a name="ln896"> </a>
<a name="ln897">		case SHOW_BOOKMARKS:</a>
<a name="ln898">			_ShowBookmarks();</a>
<a name="ln899">			break;</a>
<a name="ln900"> </a>
<a name="ln901">		case B_REFS_RECEIVED:</a>
<a name="ln902">		{</a>
<a name="ln903">			// Currently the only source of these messages is the bookmarks</a>
<a name="ln904">			// menu.</a>
<a name="ln905">			// Filter refs into URLs, this also gets rid of refs for folders.</a>
<a name="ln906">			// For clicks on sub-folders in the bookmarks menu, we have Tracker</a>
<a name="ln907">			// open the corresponding folder.</a>
<a name="ln908">			entry_ref ref;</a>
<a name="ln909">			uint32 addedCount = 0;</a>
<a name="ln910">			for (int32 i = 0; message-&gt;FindRef(&quot;refs&quot;, i, &amp;ref) == B_OK; i++) {</a>
<a name="ln911">				BEntry entry(&amp;ref);</a>
<a name="ln912">				uint32 addedSubCount = 0;</a>
<a name="ln913">				if (entry.IsDirectory()) {</a>
<a name="ln914">					BDirectory directory(&amp;entry);</a>
<a name="ln915">					_AddBookmarkURLsRecursively(directory, message,</a>
<a name="ln916">						addedSubCount);</a>
<a name="ln917">				} else {</a>
<a name="ln918">					BFile file(&amp;ref, B_READ_ONLY);</a>
<a name="ln919">					BString url;</a>
<a name="ln920">					if (_ReadURLAttr(file, url)) {</a>
<a name="ln921">						message-&gt;AddString(&quot;url&quot;, url.String());</a>
<a name="ln922">						addedSubCount++;</a>
<a name="ln923">					}</a>
<a name="ln924">				}</a>
<a name="ln925">				if (addedSubCount == 0) {</a>
<a name="ln926">					// Don't know what to do with this entry, just pass it</a>
<a name="ln927">					// on to the system to handle. Note that this may result</a>
<a name="ln928">					// in us opening other supported files via the application</a>
<a name="ln929">					// mechanism.</a>
<a name="ln930">					be_roster-&gt;Launch(&amp;ref);</a>
<a name="ln931">				}</a>
<a name="ln932">				addedCount += addedSubCount;</a>
<a name="ln933">			}</a>
<a name="ln934">			message-&gt;RemoveName(&quot;refs&quot;);</a>
<a name="ln935">			if (addedCount &gt; 10) {</a>
<a name="ln936">				BString string(B_TRANSLATE_COMMENT(&quot;Do you want to open &quot;</a>
<a name="ln937">					&quot;%addedCount bookmarks all at once?&quot;, &quot;Don't translate &quot;</a>
<a name="ln938">					&quot;variable %addedCount.&quot;));</a>
<a name="ln939">				string.ReplaceFirst(&quot;%addedCount&quot;, BString() &lt;&lt; addedCount);</a>
<a name="ln940"> </a>
<a name="ln941">				BAlert* alert = new BAlert(</a>
<a name="ln942">					B_TRANSLATE(&quot;Open bookmarks confirmation&quot;),</a>
<a name="ln943">					string.String(), B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln944">					B_TRANSLATE(&quot;Open all&quot;));</a>
<a name="ln945">				alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln946">				if (alert-&gt;Go() == 0)</a>
<a name="ln947">					break;</a>
<a name="ln948">			}</a>
<a name="ln949">			message-&gt;AddPointer(&quot;window&quot;, this);</a>
<a name="ln950">			be_app-&gt;PostMessage(message);</a>
<a name="ln951">			break;</a>
<a name="ln952">		}</a>
<a name="ln953"> </a>
<a name="ln954">		case B_SIMPLE_DATA:</a>
<a name="ln955">		{</a>
<a name="ln956">			// User possibly dropped files on this window.</a>
<a name="ln957">			// If there is more than one entry_ref, let the app handle it</a>
<a name="ln958">			// (open one new page per ref). If there is one ref, open it in</a>
<a name="ln959">			// this window.</a>
<a name="ln960">			type_code type;</a>
<a name="ln961">			int32 countFound;</a>
<a name="ln962">			if (message-&gt;GetInfo(&quot;refs&quot;, &amp;type, &amp;countFound) != B_OK</a>
<a name="ln963">				|| type != B_REF_TYPE) {</a>
<a name="ln964">				break;</a>
<a name="ln965">			}</a>
<a name="ln966">			if (countFound &gt; 1) {</a>
<a name="ln967">				message-&gt;what = B_REFS_RECEIVED;</a>
<a name="ln968">				be_app-&gt;PostMessage(message);</a>
<a name="ln969">				break;</a>
<a name="ln970">			}</a>
<a name="ln971">			entry_ref ref;</a>
<a name="ln972">			if (message-&gt;FindRef(&quot;refs&quot;, &amp;ref) != B_OK)</a>
<a name="ln973">				break;</a>
<a name="ln974">			BEntry entry(&amp;ref, true);</a>
<a name="ln975">			BPath path;</a>
<a name="ln976">			if (!entry.Exists() || entry.GetPath(&amp;path) != B_OK)</a>
<a name="ln977">				break;</a>
<a name="ln978"> </a>
<a name="ln979">			BUrl url(path);</a>
<a name="ln980">			CurrentWebView()-&gt;LoadURL(url);</a>
<a name="ln981">			break;</a>
<a name="ln982">		}</a>
<a name="ln983"> </a>
<a name="ln984">		case ZOOM_FACTOR_INCREASE:</a>
<a name="ln985">			CurrentWebView()-&gt;IncreaseZoomFactor(fZoomTextOnly);</a>
<a name="ln986">			break;</a>
<a name="ln987">		case ZOOM_FACTOR_DECREASE:</a>
<a name="ln988">			CurrentWebView()-&gt;DecreaseZoomFactor(fZoomTextOnly);</a>
<a name="ln989">			break;</a>
<a name="ln990">		case ZOOM_FACTOR_RESET:</a>
<a name="ln991">			CurrentWebView()-&gt;ResetZoomFactor();</a>
<a name="ln992">			break;</a>
<a name="ln993">		case ZOOM_TEXT_ONLY:</a>
<a name="ln994">			fZoomTextOnly = !fZoomTextOnly;</a>
<a name="ln995">			fZoomTextOnlyMenuItem-&gt;SetMarked(fZoomTextOnly);</a>
<a name="ln996">			// TODO: Would be nice to have an instant update if the page is</a>
<a name="ln997">			// already zoomed.</a>
<a name="ln998">			break;</a>
<a name="ln999"> </a>
<a name="ln1000">		case TOGGLE_FULLSCREEN:</a>
<a name="ln1001">			ToggleFullscreen();</a>
<a name="ln1002">			break;</a>
<a name="ln1003"> </a>
<a name="ln1004">		case TOGGLE_AUTO_HIDE_INTERFACE_IN_FULLSCREEN:</a>
<a name="ln1005">			_SetAutoHideInterfaceInFullscreen(</a>
<a name="ln1006">				!fAutoHideInterfaceInFullscreenMode);</a>
<a name="ln1007">			break;</a>
<a name="ln1008"> </a>
<a name="ln1009">		case CHECK_AUTO_HIDE_INTERFACE:</a>
<a name="ln1010">			_CheckAutoHideInterface();</a>
<a name="ln1011">			break;</a>
<a name="ln1012"> </a>
<a name="ln1013">		case SHOW_PAGE_SOURCE:</a>
<a name="ln1014">			CurrentWebView()-&gt;WebPage()-&gt;SendPageSource();</a>
<a name="ln1015">			break;</a>
<a name="ln1016">		case B_PAGE_SOURCE_RESULT:</a>
<a name="ln1017">			_HandlePageSourceResult(message);</a>
<a name="ln1018">			break;</a>
<a name="ln1019"> </a>
<a name="ln1020">		case EDIT_FIND_NEXT:</a>
<a name="ln1021">			CurrentWebView()-&gt;FindString(fFindTextControl-&gt;Text(), true,</a>
<a name="ln1022">				fFindCaseSensitiveCheckBox-&gt;Value());</a>
<a name="ln1023">			break;</a>
<a name="ln1024">		case FIND_TEXT_CHANGED:</a>
<a name="ln1025">		{</a>
<a name="ln1026">			bool findTextAvailable = strlen(fFindTextControl-&gt;Text()) &gt; 0;</a>
<a name="ln1027">			fFindPreviousMenuItem-&gt;SetEnabled(findTextAvailable);</a>
<a name="ln1028">			fFindNextMenuItem-&gt;SetEnabled(findTextAvailable);</a>
<a name="ln1029">			break;</a>
<a name="ln1030">		}</a>
<a name="ln1031">		case EDIT_FIND_PREVIOUS:</a>
<a name="ln1032">			CurrentWebView()-&gt;FindString(fFindTextControl-&gt;Text(), false,</a>
<a name="ln1033">				fFindCaseSensitiveCheckBox-&gt;Value());</a>
<a name="ln1034">			break;</a>
<a name="ln1035">		case EDIT_SHOW_FIND_GROUP:</a>
<a name="ln1036">			if (!fFindGroup-&gt;IsVisible())</a>
<a name="ln1037">				fFindGroup-&gt;SetVisible(true);</a>
<a name="ln1038">			fFindTextControl-&gt;MakeFocus(true);</a>
<a name="ln1039">			break;</a>
<a name="ln1040">		case EDIT_HIDE_FIND_GROUP:</a>
<a name="ln1041">			if (fFindGroup-&gt;IsVisible()) {</a>
<a name="ln1042">				fFindGroup-&gt;SetVisible(false);</a>
<a name="ln1043">				if (CurrentWebView() != NULL)</a>
<a name="ln1044">					CurrentWebView()-&gt;MakeFocus(true);</a>
<a name="ln1045">			}</a>
<a name="ln1046">			break;</a>
<a name="ln1047"> </a>
<a name="ln1048">		case B_CUT:</a>
<a name="ln1049">		case B_COPY:</a>
<a name="ln1050">		case B_PASTE:</a>
<a name="ln1051">		{</a>
<a name="ln1052">			BTextView* textView = dynamic_cast&lt;BTextView*&gt;(CurrentFocus());</a>
<a name="ln1053">			if (textView != NULL)</a>
<a name="ln1054">				textView-&gt;MessageReceived(message);</a>
<a name="ln1055">			else if (CurrentWebView() != NULL)</a>
<a name="ln1056">				CurrentWebView()-&gt;MessageReceived(message);</a>
<a name="ln1057">			break;</a>
<a name="ln1058">		}</a>
<a name="ln1059"> </a>
<a name="ln1060">		case B_EDITING_CAPABILITIES_RESULT:</a>
<a name="ln1061">		{</a>
<a name="ln1062">			BWebView* webView;</a>
<a name="ln1063">			if (message-&gt;FindPointer(&quot;view&quot;,</a>
<a name="ln1064">					reinterpret_cast&lt;void**&gt;(&amp;webView)) != B_OK</a>
<a name="ln1065">				|| webView != CurrentWebView()) {</a>
<a name="ln1066">				break;</a>
<a name="ln1067">			}</a>
<a name="ln1068">			bool canCut;</a>
<a name="ln1069">			bool canCopy;</a>
<a name="ln1070">			bool canPaste;</a>
<a name="ln1071">			if (message-&gt;FindBool(&quot;can cut&quot;, &amp;canCut) != B_OK)</a>
<a name="ln1072">				canCut = false;</a>
<a name="ln1073">			if (message-&gt;FindBool(&quot;can copy&quot;, &amp;canCopy) != B_OK)</a>
<a name="ln1074">				canCopy = false;</a>
<a name="ln1075">			if (message-&gt;FindBool(&quot;can paste&quot;, &amp;canPaste) != B_OK)</a>
<a name="ln1076">				canPaste = false;</a>
<a name="ln1077">			fCutMenuItem-&gt;SetEnabled(canCut);</a>
<a name="ln1078">			fCopyMenuItem-&gt;SetEnabled(canCopy);</a>
<a name="ln1079">			fPasteMenuItem-&gt;SetEnabled(canPaste);</a>
<a name="ln1080">			break;</a>
<a name="ln1081">		}</a>
<a name="ln1082"> </a>
<a name="ln1083">		case SHOW_DOWNLOAD_WINDOW:</a>
<a name="ln1084">		case SHOW_SETTINGS_WINDOW:</a>
<a name="ln1085">		case SHOW_CONSOLE_WINDOW:</a>
<a name="ln1086">		case SHOW_COOKIE_WINDOW:</a>
<a name="ln1087">			message-&gt;AddUInt32(&quot;workspaces&quot;, Workspaces());</a>
<a name="ln1088">			be_app-&gt;PostMessage(message);</a>
<a name="ln1089">			break;</a>
<a name="ln1090"> </a>
<a name="ln1091">		case CLOSE_TAB:</a>
<a name="ln1092">			if (fTabManager-&gt;CountTabs() &gt; 1) {</a>
<a name="ln1093">				int32 index;</a>
<a name="ln1094">				if (message-&gt;FindInt32(&quot;tab index&quot;, &amp;index) != B_OK)</a>
<a name="ln1095">					index = fTabManager-&gt;SelectedTabIndex();</a>
<a name="ln1096">				_ShutdownTab(index);</a>
<a name="ln1097">				_UpdateTabGroupVisibility();</a>
<a name="ln1098">			} else</a>
<a name="ln1099">				PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln1100">			break;</a>
<a name="ln1101"> </a>
<a name="ln1102">		case SELECT_TAB:</a>
<a name="ln1103">		{</a>
<a name="ln1104">			int32 index;</a>
<a name="ln1105">			if (message-&gt;FindInt32(&quot;tab index&quot;, &amp;index) == B_OK</a>
<a name="ln1106">				&amp;&amp; fTabManager-&gt;SelectedTabIndex() != index</a>
<a name="ln1107">				&amp;&amp; fTabManager-&gt;CountTabs() &gt; index) {</a>
<a name="ln1108">				fTabManager-&gt;SelectTab(index);</a>
<a name="ln1109">			}</a>
<a name="ln1110"> </a>
<a name="ln1111">			break;</a>
<a name="ln1112">		}</a>
<a name="ln1113"> </a>
<a name="ln1114">		case TAB_CHANGED:</a>
<a name="ln1115">		{</a>
<a name="ln1116">			// This message may be received also when the last tab closed,</a>
<a name="ln1117">			// i.e. with index == -1.</a>
<a name="ln1118">			int32 index;</a>
<a name="ln1119">			if (message-&gt;FindInt32(&quot;tab index&quot;, &amp;index) != B_OK)</a>
<a name="ln1120">				index = -1;</a>
<a name="ln1121">			_TabChanged(index);</a>
<a name="ln1122">			break;</a>
<a name="ln1123">		}</a>
<a name="ln1124"> </a>
<a name="ln1125">		case SETTINGS_VALUE_CHANGED:</a>
<a name="ln1126">		{</a>
<a name="ln1127">			BString name;</a>
<a name="ln1128">			if (message-&gt;FindString(&quot;name&quot;, &amp;name) != B_OK)</a>
<a name="ln1129">				break;</a>
<a name="ln1130">			bool flag;</a>
<a name="ln1131">			BString string;</a>
<a name="ln1132">			uint32 value;</a>
<a name="ln1133">			if (name == kSettingsKeyShowTabsIfSinglePageOpen</a>
<a name="ln1134">				&amp;&amp; message-&gt;FindBool(&quot;value&quot;, &amp;flag) == B_OK) {</a>
<a name="ln1135">				if (fShowTabsIfSinglePageOpen != flag) {</a>
<a name="ln1136">					fShowTabsIfSinglePageOpen = flag;</a>
<a name="ln1137">					_UpdateTabGroupVisibility();</a>
<a name="ln1138">				}</a>
<a name="ln1139">			} else if (name == kSettingsKeyAutoHidePointer</a>
<a name="ln1140">				&amp;&amp; message-&gt;FindBool(&quot;value&quot;, &amp;flag) == B_OK) {</a>
<a name="ln1141">				fAutoHidePointer = flag;</a>
<a name="ln1142">				if (CurrentWebView())</a>
<a name="ln1143">					CurrentWebView()-&gt;SetAutoHidePointer(fAutoHidePointer);</a>
<a name="ln1144">			} else if (name == kSettingsKeyStartPageURL</a>
<a name="ln1145">				&amp;&amp; message-&gt;FindString(&quot;value&quot;, &amp;string) == B_OK) {</a>
<a name="ln1146">				fStartPageURL = string;</a>
<a name="ln1147">			} else if (name == kSettingsKeySearchPageURL</a>
<a name="ln1148">				&amp;&amp; message-&gt;FindString(&quot;value&quot;, &amp;string) == B_OK) {</a>
<a name="ln1149">				fSearchPageURL = string;</a>
<a name="ln1150">			} else if (name == kSettingsKeyNewWindowPolicy</a>
<a name="ln1151">				&amp;&amp; message-&gt;FindUInt32(&quot;value&quot;, &amp;value) == B_OK) {</a>
<a name="ln1152">				fNewWindowPolicy = value;</a>
<a name="ln1153">			} else if (name == kSettingsKeyNewTabPolicy</a>
<a name="ln1154">				&amp;&amp; message-&gt;FindUInt32(&quot;value&quot;, &amp;value) == B_OK) {</a>
<a name="ln1155">				fNewTabPolicy = value;</a>
<a name="ln1156">			} else if (name == kSettingsKeyAutoHideInterfaceInFullscreenMode</a>
<a name="ln1157">				&amp;&amp; message-&gt;FindBool(&quot;value&quot;, &amp;flag) == B_OK) {</a>
<a name="ln1158">				_SetAutoHideInterfaceInFullscreen(flag);</a>
<a name="ln1159">			} else if (name == kSettingsKeyShowHomeButton</a>
<a name="ln1160">				&amp;&amp; message-&gt;FindBool(&quot;value&quot;, &amp;flag) == B_OK) {</a>
<a name="ln1161">				if (flag)</a>
<a name="ln1162">					fHomeButton-&gt;Show();</a>
<a name="ln1163">				else</a>
<a name="ln1164">					fHomeButton-&gt;Hide();</a>
<a name="ln1165">			} else if (name == kSettingsShowBookmarkBar</a>
<a name="ln1166">				&amp;&amp; message-&gt;FindBool(&quot;value&quot;, &amp;flag) == B_OK) {</a>
<a name="ln1167">				_ShowBookmarkBar(flag);</a>
<a name="ln1168">			}</a>
<a name="ln1169">			break;</a>
<a name="ln1170">		}</a>
<a name="ln1171">		case ADD_CONSOLE_MESSAGE:</a>
<a name="ln1172">			be_app-&gt;PostMessage(message);</a>
<a name="ln1173">			BWebWindow::MessageReceived(message);</a>
<a name="ln1174">			break;</a>
<a name="ln1175"> </a>
<a name="ln1176">		default:</a>
<a name="ln1177">			BWebWindow::MessageReceived(message);</a>
<a name="ln1178">			break;</a>
<a name="ln1179">	}</a>
<a name="ln1180">}</a>
<a name="ln1181"> </a>
<a name="ln1182"> </a>
<a name="ln1183">status_t</a>
<a name="ln1184">BrowserWindow::Archive(BMessage* archive, bool deep) const</a>
<a name="ln1185">{</a>
<a name="ln1186">	status_t ret = archive-&gt;AddRect(&quot;window frame&quot;, Frame());</a>
<a name="ln1187"> </a>
<a name="ln1188">	for (int i = 0; i &lt; fTabManager-&gt;CountTabs(); i++) {</a>
<a name="ln1189">		BWebView* view = dynamic_cast&lt;BWebView*&gt;(fTabManager-&gt;ViewForTab(i));</a>
<a name="ln1190">		if (view == NULL) {</a>
<a name="ln1191">			continue;</a>
<a name="ln1192">		}</a>
<a name="ln1193"> </a>
<a name="ln1194">		if (ret == B_OK)</a>
<a name="ln1195">			ret = archive-&gt;AddString(&quot;tab&quot;, view-&gt;MainFrameURL());</a>
<a name="ln1196">	}</a>
<a name="ln1197"> </a>
<a name="ln1198">	return ret;</a>
<a name="ln1199">}</a>
<a name="ln1200"> </a>
<a name="ln1201"> </a>
<a name="ln1202">bool</a>
<a name="ln1203">BrowserWindow::QuitRequested()</a>
<a name="ln1204">{</a>
<a name="ln1205">	// TODO: Check for modified form data and ask user for confirmation, etc.</a>
<a name="ln1206"> </a>
<a name="ln1207">	BMessage message(WINDOW_CLOSED);</a>
<a name="ln1208">	Archive(&amp;message);</a>
<a name="ln1209"> </a>
<a name="ln1210">	// Iterate over all tabs to delete all BWebViews.</a>
<a name="ln1211">	// Do this here, so WebKit tear down happens earlier.</a>
<a name="ln1212">	SetCurrentWebView(NULL);</a>
<a name="ln1213">	while (fTabManager-&gt;CountTabs() &gt; 0)</a>
<a name="ln1214">		_ShutdownTab(0);</a>
<a name="ln1215"> </a>
<a name="ln1216">	message.AddRect(&quot;window frame&quot;, WindowFrame());</a>
<a name="ln1217">	be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln1218">	return true;</a>
<a name="ln1219">}</a>
<a name="ln1220"> </a>
<a name="ln1221"> </a>
<a name="ln1222">void</a>
<a name="ln1223">BrowserWindow::MenusBeginning()</a>
<a name="ln1224">{</a>
<a name="ln1225">	_UpdateHistoryMenu();</a>
<a name="ln1226">	_UpdateClipboardItems();</a>
<a name="ln1227">	fMenusRunning = true;</a>
<a name="ln1228">}</a>
<a name="ln1229"> </a>
<a name="ln1230"> </a>
<a name="ln1231">void</a>
<a name="ln1232">BrowserWindow::MenusEnded()</a>
<a name="ln1233">{</a>
<a name="ln1234">	fMenusRunning = false;</a>
<a name="ln1235">}</a>
<a name="ln1236"> </a>
<a name="ln1237"> </a>
<a name="ln1238">void</a>
<a name="ln1239">BrowserWindow::ScreenChanged(BRect screenSize, color_space format)</a>
<a name="ln1240">{</a>
<a name="ln1241">	if (fIsFullscreen)</a>
<a name="ln1242">		_ResizeToScreen();</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245"> </a>
<a name="ln1246">void</a>
<a name="ln1247">BrowserWindow::WorkspacesChanged(uint32 oldWorkspaces, uint32 newWorkspaces)</a>
<a name="ln1248">{</a>
<a name="ln1249">	if (fIsFullscreen)</a>
<a name="ln1250">		_ResizeToScreen();</a>
<a name="ln1251">}</a>
<a name="ln1252"> </a>
<a name="ln1253"> </a>
<a name="ln1254">static bool</a>
<a name="ln1255">viewIsChild(const BView* parent, const BView* view)</a>
<a name="ln1256">{</a>
<a name="ln1257">	if (parent == view)</a>
<a name="ln1258">		return true;</a>
<a name="ln1259"> </a>
<a name="ln1260">	int32 count = parent-&gt;CountChildren();</a>
<a name="ln1261">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1262">		BView* child = parent-&gt;ChildAt(i);</a>
<a name="ln1263">		if (viewIsChild(child, view))</a>
<a name="ln1264">			return true;</a>
<a name="ln1265">	}</a>
<a name="ln1266">	return false;</a>
<a name="ln1267">}</a>
<a name="ln1268"> </a>
<a name="ln1269"> </a>
<a name="ln1270">void</a>
<a name="ln1271">BrowserWindow::SetCurrentWebView(BWebView* webView)</a>
<a name="ln1272">{</a>
<a name="ln1273">	if (webView == CurrentWebView())</a>
<a name="ln1274">		return;</a>
<a name="ln1275"> </a>
<a name="ln1276">	if (CurrentWebView() != NULL) {</a>
<a name="ln1277">		// Remember the currently focused view before switching tabs,</a>
<a name="ln1278">		// so that we can revert the focus when switching back to this tab</a>
<a name="ln1279">		// later.</a>
<a name="ln1280">		PageUserData* userData = static_cast&lt;PageUserData*&gt;(</a>
<a name="ln1281">			CurrentWebView()-&gt;GetUserData());</a>
<a name="ln1282">		if (userData == NULL) {</a>
<a name="ln1283">			userData = new PageUserData(CurrentFocus());</a>
<a name="ln1284">			CurrentWebView()-&gt;SetUserData(userData);</a>
<a name="ln1285">		}</a>
<a name="ln1286">		userData-&gt;SetFocusedView(CurrentFocus());</a>
<a name="ln1287">		userData-&gt;SetURLInputContents(fURLInputGroup-&gt;Text());</a>
<a name="ln1288">		int32 selectionStart;</a>
<a name="ln1289">		int32 selectionEnd;</a>
<a name="ln1290">		fURLInputGroup-&gt;TextView()-&gt;GetSelection(&amp;selectionStart,</a>
<a name="ln1291">			&amp;selectionEnd);</a>
<a name="ln1292">		userData-&gt;SetURLInputSelection(selectionStart, selectionEnd);</a>
<a name="ln1293">	}</a>
<a name="ln1294"> </a>
<a name="ln1295">	BWebWindow::SetCurrentWebView(webView);</a>
<a name="ln1296"> </a>
<a name="ln1297">	if (webView != NULL) {</a>
<a name="ln1298">		webView-&gt;SetAutoHidePointer(fAutoHidePointer);</a>
<a name="ln1299"> </a>
<a name="ln1300">		_UpdateTitle(webView-&gt;MainFrameTitle());</a>
<a name="ln1301"> </a>
<a name="ln1302">		// Restore the previous focus or focus the web view.</a>
<a name="ln1303">		PageUserData* userData = static_cast&lt;PageUserData*&gt;(</a>
<a name="ln1304">			webView-&gt;GetUserData());</a>
<a name="ln1305">		BView* focusedView = NULL;</a>
<a name="ln1306">		if (userData != NULL)</a>
<a name="ln1307">			focusedView = userData-&gt;FocusedView();</a>
<a name="ln1308"> </a>
<a name="ln1309">		if (focusedView != NULL</a>
<a name="ln1310">			&amp;&amp; viewIsChild(GetLayout()-&gt;View(), focusedView)) {</a>
<a name="ln1311">			focusedView-&gt;MakeFocus(true);</a>
<a name="ln1312">		} else</a>
<a name="ln1313">			webView-&gt;MakeFocus(true);</a>
<a name="ln1314"> </a>
<a name="ln1315">		bool state = fURLInputGroup-&gt;IsURLInputLocked();</a>
<a name="ln1316">		fURLInputGroup-&gt;LockURLInput(false);</a>
<a name="ln1317">			// Unlock it so the following code can update the URL</a>
<a name="ln1318"> </a>
<a name="ln1319">		if (userData != NULL) {</a>
<a name="ln1320">			fURLInputGroup-&gt;SetPageIcon(userData-&gt;PageIcon());</a>
<a name="ln1321">			if (userData-&gt;URLInputContents().Length())</a>
<a name="ln1322">				fURLInputGroup-&gt;SetText(userData-&gt;URLInputContents());</a>
<a name="ln1323">			else</a>
<a name="ln1324">				fURLInputGroup-&gt;SetText(webView-&gt;MainFrameURL());</a>
<a name="ln1325">			if (userData-&gt;URLInputSelectionStart() &gt;= 0) {</a>
<a name="ln1326">				fURLInputGroup-&gt;TextView()-&gt;Select(</a>
<a name="ln1327">					userData-&gt;URLInputSelectionStart(),</a>
<a name="ln1328">					userData-&gt;URLInputSelectionEnd());</a>
<a name="ln1329">			}</a>
<a name="ln1330">		} else {</a>
<a name="ln1331">			fURLInputGroup-&gt;SetPageIcon(NULL);</a>
<a name="ln1332">			fURLInputGroup-&gt;SetText(webView-&gt;MainFrameURL());</a>
<a name="ln1333">		}</a>
<a name="ln1334"> </a>
<a name="ln1335">		fURLInputGroup-&gt;LockURLInput(state);</a>
<a name="ln1336">			// Restore the state</a>
<a name="ln1337"> </a>
<a name="ln1338">		// Trigger update of the interface to the new page, by requesting</a>
<a name="ln1339">		// to resend all notifications.</a>
<a name="ln1340">		webView-&gt;WebPage()-&gt;ResendNotifications();</a>
<a name="ln1341">	} else</a>
<a name="ln1342">		_UpdateTitle(&quot;&quot;);</a>
<a name="ln1343">}</a>
<a name="ln1344"> </a>
<a name="ln1345"> </a>
<a name="ln1346">bool</a>
<a name="ln1347">BrowserWindow::IsBlankTab() const</a>
<a name="ln1348">{</a>
<a name="ln1349">	if (CurrentWebView() == NULL)</a>
<a name="ln1350">		return false;</a>
<a name="ln1351">	BString requestedURL = CurrentWebView()-&gt;MainFrameRequestedURL();</a>
<a name="ln1352">	return requestedURL.Length() == 0</a>
<a name="ln1353">		|| requestedURL == _NewTabURL(fTabManager-&gt;CountTabs() == 1);</a>
<a name="ln1354">}</a>
<a name="ln1355"> </a>
<a name="ln1356"> </a>
<a name="ln1357">void</a>
<a name="ln1358">BrowserWindow::CreateNewTab(const BString&amp; _url, bool select,</a>
<a name="ln1359">	BWebView* webView)</a>
<a name="ln1360">{</a>
<a name="ln1361">	bool applyNewPagePolicy = webView == NULL;</a>
<a name="ln1362">	// Executed in app thread (new BWebPage needs to be created in app thread).</a>
<a name="ln1363">	if (webView == NULL)</a>
<a name="ln1364">		webView = new BWebView(&quot;web view&quot;, fContext);</a>
<a name="ln1365"> </a>
<a name="ln1366">	bool isNewWindow = fTabManager-&gt;CountTabs() == 0;</a>
<a name="ln1367"> </a>
<a name="ln1368">	fTabManager-&gt;AddTab(webView, B_TRANSLATE(&quot;New tab&quot;));</a>
<a name="ln1369"> </a>
<a name="ln1370">	BString url(_url);</a>
<a name="ln1371">	if (applyNewPagePolicy &amp;&amp; url.Length() == 0)</a>
<a name="ln1372">		url = _NewTabURL(isNewWindow);</a>
<a name="ln1373"> </a>
<a name="ln1374">	if (url.Length() &gt; 0)</a>
<a name="ln1375">		webView-&gt;LoadURL(url.String());</a>
<a name="ln1376"> </a>
<a name="ln1377">	if (select) {</a>
<a name="ln1378">		fTabManager-&gt;SelectTab(fTabManager-&gt;CountTabs() - 1);</a>
<a name="ln1379">		SetCurrentWebView(webView);</a>
<a name="ln1380">		webView-&gt;WebPage()-&gt;ResendNotifications();</a>
<a name="ln1381">		fURLInputGroup-&gt;SetPageIcon(NULL);</a>
<a name="ln1382">		fURLInputGroup-&gt;SetText(url.String());</a>
<a name="ln1383">		fURLInputGroup-&gt;MakeFocus(true);</a>
<a name="ln1384">	}</a>
<a name="ln1385"> </a>
<a name="ln1386">	_ShowInterface(true);</a>
<a name="ln1387">	_UpdateTabGroupVisibility();</a>
<a name="ln1388">}</a>
<a name="ln1389"> </a>
<a name="ln1390"> </a>
<a name="ln1391">BRect</a>
<a name="ln1392">BrowserWindow::WindowFrame() const</a>
<a name="ln1393">{</a>
<a name="ln1394">	if (fIsFullscreen)</a>
<a name="ln1395">		return fNonFullscreenWindowFrame;</a>
<a name="ln1396">	else</a>
<a name="ln1397">		return Frame();</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400"> </a>
<a name="ln1401">void</a>
<a name="ln1402">BrowserWindow::ToggleFullscreen()</a>
<a name="ln1403">{</a>
<a name="ln1404">	if (fIsFullscreen) {</a>
<a name="ln1405">		MoveTo(fNonFullscreenWindowFrame.LeftTop());</a>
<a name="ln1406">		ResizeTo(fNonFullscreenWindowFrame.Width(),</a>
<a name="ln1407">			fNonFullscreenWindowFrame.Height());</a>
<a name="ln1408"> </a>
<a name="ln1409">		SetFlags(Flags() &amp; ~(B_NOT_RESIZABLE | B_NOT_MOVABLE));</a>
<a name="ln1410">		SetLook(B_DOCUMENT_WINDOW_LOOK);</a>
<a name="ln1411"> </a>
<a name="ln1412">		_ShowInterface(true);</a>
<a name="ln1413">	} else {</a>
<a name="ln1414">		fNonFullscreenWindowFrame = Frame();</a>
<a name="ln1415">		_ResizeToScreen();</a>
<a name="ln1416"> </a>
<a name="ln1417">		SetFlags(Flags() | (B_NOT_RESIZABLE | B_NOT_MOVABLE));</a>
<a name="ln1418">		SetLook(B_TITLED_WINDOW_LOOK);</a>
<a name="ln1419">	}</a>
<a name="ln1420">	fIsFullscreen = !fIsFullscreen;</a>
<a name="ln1421">	fFullscreenItem-&gt;SetMarked(fIsFullscreen);</a>
<a name="ln1422">	fToggleFullscreenButton-&gt;SetVisible(fIsFullscreen);</a>
<a name="ln1423">}</a>
<a name="ln1424"> </a>
<a name="ln1425"> </a>
<a name="ln1426">// #pragma mark - Notification API</a>
<a name="ln1427"> </a>
<a name="ln1428"> </a>
<a name="ln1429">void</a>
<a name="ln1430">BrowserWindow::NavigationRequested(const BString&amp; url, BWebView* view)</a>
<a name="ln1431">{</a>
<a name="ln1432">}</a>
<a name="ln1433"> </a>
<a name="ln1434"> </a>
<a name="ln1435">void</a>
<a name="ln1436">BrowserWindow::NewWindowRequested(const BString&amp; url, bool primaryAction)</a>
<a name="ln1437">{</a>
<a name="ln1438">	// Always open new windows in the application thread, since</a>
<a name="ln1439">	// creating a BWebView will try to grab the application lock.</a>
<a name="ln1440">	// But our own WebPage may already try to lock us from within</a>
<a name="ln1441">	// the application thread -&gt; dead-lock. Thus we can't wait for</a>
<a name="ln1442">	// a reply here.</a>
<a name="ln1443">	BMessage message(NEW_TAB);</a>
<a name="ln1444">	message.AddPointer(&quot;window&quot;, this);</a>
<a name="ln1445">	message.AddString(&quot;url&quot;, url);</a>
<a name="ln1446">	message.AddBool(&quot;select&quot;, primaryAction);</a>
<a name="ln1447">	be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln1448">}</a>
<a name="ln1449"> </a>
<a name="ln1450"> </a>
<a name="ln1451">void</a>
<a name="ln1452">BrowserWindow::NewPageCreated(BWebView* view, BRect windowFrame,</a>
<a name="ln1453">	bool modalDialog, bool resizable, bool activate)</a>
<a name="ln1454">{</a>
<a name="ln1455">	if (windowFrame.IsValid()) {</a>
<a name="ln1456">		BrowserWindow* window = new BrowserWindow(windowFrame, fAppSettings,</a>
<a name="ln1457">			BString(), fContext, INTERFACE_ELEMENT_STATUS,</a>
<a name="ln1458">			view);</a>
<a name="ln1459">		window-&gt;Show();</a>
<a name="ln1460">	} else</a>
<a name="ln1461">		CreateNewTab(BString(), activate, view);</a>
<a name="ln1462">}</a>
<a name="ln1463"> </a>
<a name="ln1464"> </a>
<a name="ln1465">void</a>
<a name="ln1466">BrowserWindow::CloseWindowRequested(BWebView* view)</a>
<a name="ln1467">{</a>
<a name="ln1468">	int32 index = fTabManager-&gt;TabForView(view);</a>
<a name="ln1469">	if (index &lt; 0) {</a>
<a name="ln1470">		// Tab is already gone.</a>
<a name="ln1471">		return;</a>
<a name="ln1472">	}</a>
<a name="ln1473">	BMessage message(CLOSE_TAB);</a>
<a name="ln1474">	message.AddInt32(&quot;tab index&quot;, index);</a>
<a name="ln1475">	PostMessage(&amp;message, this);</a>
<a name="ln1476">}</a>
<a name="ln1477"> </a>
<a name="ln1478"> </a>
<a name="ln1479">void</a>
<a name="ln1480">BrowserWindow::LoadNegotiating(const BString&amp; url, BWebView* view)</a>
<a name="ln1481">{</a>
<a name="ln1482">	if (view != CurrentWebView()) {</a>
<a name="ln1483">		// Update the userData contents instead so the user sees</a>
<a name="ln1484">		// the correct URL when they switch back to that tab.</a>
<a name="ln1485">		PageUserData* userData = static_cast&lt;PageUserData*&gt;(</a>
<a name="ln1486">			view-&gt;GetUserData());</a>
<a name="ln1487">		if (userData != NULL &amp;&amp; userData-&gt;URLInputContents().Length() == 0) {</a>
<a name="ln1488">			userData-&gt;SetURLInputContents(url);</a>
<a name="ln1489">		}</a>
<a name="ln1490">	}</a>
<a name="ln1491"> </a>
<a name="ln1492">	fURLInputGroup-&gt;SetText(url.String());</a>
<a name="ln1493"> </a>
<a name="ln1494">	BString status(B_TRANSLATE(&quot;Requesting %url&quot;));</a>
<a name="ln1495">	status.ReplaceFirst(&quot;%url&quot;, url);</a>
<a name="ln1496">	view-&gt;WebPage()-&gt;SetStatusMessage(status);</a>
<a name="ln1497">}</a>
<a name="ln1498"> </a>
<a name="ln1499"> </a>
<a name="ln1500">void</a>
<a name="ln1501">BrowserWindow::LoadCommitted(const BString&amp; url, BWebView* view)</a>
<a name="ln1502">{</a>
<a name="ln1503">	if (view != CurrentWebView())</a>
<a name="ln1504">		return;</a>
<a name="ln1505"> </a>
<a name="ln1506">	// This hook is invoked when the load is commited.</a>
<a name="ln1507">	fURLInputGroup-&gt;SetText(url.String());</a>
<a name="ln1508"> </a>
<a name="ln1509">	BString status(B_TRANSLATE(&quot;Loading %url&quot;));</a>
<a name="ln1510">	status.ReplaceFirst(&quot;%url&quot;, url);</a>
<a name="ln1511">	view-&gt;WebPage()-&gt;SetStatusMessage(status);</a>
<a name="ln1512">}</a>
<a name="ln1513"> </a>
<a name="ln1514"> </a>
<a name="ln1515">void</a>
<a name="ln1516">BrowserWindow::LoadProgress(float progress, BWebView* view)</a>
<a name="ln1517">{</a>
<a name="ln1518">	if (view != CurrentWebView())</a>
<a name="ln1519">		return;</a>
<a name="ln1520"> </a>
<a name="ln1521">	if (progress &lt; 100 &amp;&amp; fLoadingProgressBar-&gt;IsHidden())</a>
<a name="ln1522">		_ShowProgressBar(true);</a>
<a name="ln1523">	else if (progress == 100 &amp;&amp; !fLoadingProgressBar-&gt;IsHidden())</a>
<a name="ln1524">		_ShowProgressBar(false);</a>
<a name="ln1525">	fLoadingProgressBar-&gt;SetTo(progress);</a>
<a name="ln1526">}</a>
<a name="ln1527"> </a>
<a name="ln1528"> </a>
<a name="ln1529">void</a>
<a name="ln1530">BrowserWindow::LoadFailed(const BString&amp; url, BWebView* view)</a>
<a name="ln1531">{</a>
<a name="ln1532">	if (view != CurrentWebView())</a>
<a name="ln1533">		return;</a>
<a name="ln1534"> </a>
<a name="ln1535">	BString status(B_TRANSLATE_COMMENT(&quot;%url failed&quot;, &quot;Loading URL failed. &quot;</a>
<a name="ln1536">		&quot;Don't translate variable %url.&quot;));</a>
<a name="ln1537">	status.ReplaceFirst(&quot;%url&quot;, url);</a>
<a name="ln1538">	view-&gt;WebPage()-&gt;SetStatusMessage(status);</a>
<a name="ln1539">	if (!fLoadingProgressBar-&gt;IsHidden())</a>
<a name="ln1540">		fLoadingProgressBar-&gt;Hide();</a>
<a name="ln1541">}</a>
<a name="ln1542"> </a>
<a name="ln1543"> </a>
<a name="ln1544">void</a>
<a name="ln1545">BrowserWindow::LoadFinished(const BString&amp; url, BWebView* view)</a>
<a name="ln1546">{</a>
<a name="ln1547">	if (view != CurrentWebView())</a>
<a name="ln1548">		return;</a>
<a name="ln1549"> </a>
<a name="ln1550">	fURLInputGroup-&gt;SetText(url.String());</a>
<a name="ln1551"> </a>
<a name="ln1552">	BString status(B_TRANSLATE_COMMENT(&quot;%url finished&quot;, &quot;Loading URL &quot;</a>
<a name="ln1553">		&quot;finished. Don't translate variable %url.&quot;));</a>
<a name="ln1554">	status.ReplaceFirst(&quot;%url&quot;, url);</a>
<a name="ln1555">	view-&gt;WebPage()-&gt;SetStatusMessage(status);</a>
<a name="ln1556">	if (!fLoadingProgressBar-&gt;IsHidden())</a>
<a name="ln1557">		fLoadingProgressBar-&gt;Hide();</a>
<a name="ln1558"> </a>
<a name="ln1559">	NavigationCapabilitiesChanged(fBackButton-&gt;IsEnabled(),</a>
<a name="ln1560">		fForwardButton-&gt;IsEnabled(), false, view);</a>
<a name="ln1561"> </a>
<a name="ln1562">	int32 tabIndex = fTabManager-&gt;TabForView(view);</a>
<a name="ln1563">	if (tabIndex &gt; 0 &amp;&amp; strcmp(B_TRANSLATE(&quot;New tab&quot;),</a>
<a name="ln1564">		fTabManager-&gt;TabLabel(tabIndex)) == 0)</a>
<a name="ln1565">			fTabManager-&gt;SetTabLabel(tabIndex, url);</a>
<a name="ln1566">}</a>
<a name="ln1567"> </a>
<a name="ln1568"> </a>
<a name="ln1569">void</a>
<a name="ln1570">BrowserWindow::MainDocumentError(const BString&amp; failingURL,</a>
<a name="ln1571">	const BString&amp; localizedDescription, BWebView* view)</a>
<a name="ln1572">{</a>
<a name="ln1573">	// Make sure we show the page that contains the view.</a>
<a name="ln1574">	if (!_ShowPage(view))</a>
<a name="ln1575">		return;</a>
<a name="ln1576"> </a>
<a name="ln1577">	// Try delegating the URL to an external app instead.</a>
<a name="ln1578">	int32 at = failingURL.FindFirst(&quot;:&quot;);</a>
<a name="ln1579">	if (at &gt; 0) {</a>
<a name="ln1580">		BString proto;</a>
<a name="ln1581">		failingURL.CopyInto(proto, 0, at);</a>
<a name="ln1582"> </a>
<a name="ln1583">		bool handled = false;</a>
<a name="ln1584"> </a>
<a name="ln1585">		for (unsigned int i = 0; i &lt; sizeof(kHandledProtocols) / sizeof(char*);</a>
<a name="ln1586">				i++) {</a>
<a name="ln1587">			handled = (proto == kHandledProtocols[i]);</a>
<a name="ln1588">			if (handled)</a>
<a name="ln1589">				break;</a>
<a name="ln1590">		}</a>
<a name="ln1591"> </a>
<a name="ln1592">		if (!handled) {</a>
<a name="ln1593">			_SmartURLHandler(failingURL);</a>
<a name="ln1594">			return;</a>
<a name="ln1595">		}</a>
<a name="ln1596">	}</a>
<a name="ln1597"> </a>
<a name="ln1598">	BWebWindow::MainDocumentError(failingURL, localizedDescription, view);</a>
<a name="ln1599"> </a>
<a name="ln1600">	// TODO: Remove the failing URL from the BrowsingHistory!</a>
<a name="ln1601">}</a>
<a name="ln1602"> </a>
<a name="ln1603"> </a>
<a name="ln1604">void</a>
<a name="ln1605">BrowserWindow::TitleChanged(const BString&amp; title, BWebView* view)</a>
<a name="ln1606">{</a>
<a name="ln1607">	int32 tabIndex = fTabManager-&gt;TabForView(view);</a>
<a name="ln1608">	if (tabIndex &lt; 0)</a>
<a name="ln1609">		return;</a>
<a name="ln1610"> </a>
<a name="ln1611">	fTabManager-&gt;SetTabLabel(tabIndex, title);</a>
<a name="ln1612"> </a>
<a name="ln1613">	if (view != CurrentWebView())</a>
<a name="ln1614">		return;</a>
<a name="ln1615"> </a>
<a name="ln1616">	_UpdateTitle(title);</a>
<a name="ln1617">}</a>
<a name="ln1618"> </a>
<a name="ln1619"> </a>
<a name="ln1620">void</a>
<a name="ln1621">BrowserWindow::IconReceived(const BBitmap* icon, BWebView* view)</a>
<a name="ln1622">{</a>
<a name="ln1623">	// The view may already be gone, since this notification arrives</a>
<a name="ln1624">	// asynchronously.</a>
<a name="ln1625">	if (!fTabManager-&gt;HasView(view))</a>
<a name="ln1626">		return;</a>
<a name="ln1627"> </a>
<a name="ln1628">	_SetPageIcon(view, icon);</a>
<a name="ln1629">}</a>
<a name="ln1630"> </a>
<a name="ln1631"> </a>
<a name="ln1632">void</a>
<a name="ln1633">BrowserWindow::ResizeRequested(float width, float height, BWebView* view)</a>
<a name="ln1634">{</a>
<a name="ln1635">	if (view != CurrentWebView())</a>
<a name="ln1636">		return;</a>
<a name="ln1637"> </a>
<a name="ln1638">	// Ignore request when there is more than one BWebView embedded.</a>
<a name="ln1639">	if (fTabManager-&gt;CountTabs() &gt; 1)</a>
<a name="ln1640">		return;</a>
<a name="ln1641"> </a>
<a name="ln1642">	// Make sure the new frame is not larger than the screen frame minus</a>
<a name="ln1643">	// window decorator border.</a>
<a name="ln1644">	BScreen screen(this);</a>
<a name="ln1645">	BRect screenFrame = screen.Frame();</a>
<a name="ln1646">	BRect decoratorFrame = DecoratorFrame();</a>
<a name="ln1647">	BRect frame = Frame();</a>
<a name="ln1648"> </a>
<a name="ln1649">	screenFrame.left += decoratorFrame.left - frame.left;</a>
<a name="ln1650">	screenFrame.right += decoratorFrame.right - frame.right;</a>
<a name="ln1651">	screenFrame.top += decoratorFrame.top - frame.top;</a>
<a name="ln1652">	screenFrame.bottom += decoratorFrame.bottom - frame.bottom;</a>
<a name="ln1653"> </a>
<a name="ln1654">	width = min_c(width, screen.Frame().Width());</a>
<a name="ln1655">	height = min_c(height, screen.Frame().Height());</a>
<a name="ln1656"> </a>
<a name="ln1657">	frame.right = frame.left + width;</a>
<a name="ln1658">	frame.bottom = frame.top + height;</a>
<a name="ln1659"> </a>
<a name="ln1660">	// frame is now not larger than screenFrame, but may still be partly outside</a>
<a name="ln1661">	if (!screenFrame.Contains(frame)) {</a>
<a name="ln1662">		if (frame.left &lt; screenFrame.left)</a>
<a name="ln1663">			frame.OffsetBy(screenFrame.left - frame.left, 0);</a>
<a name="ln1664">		else if (frame.right &gt; screenFrame.right)</a>
<a name="ln1665">			frame.OffsetBy(screenFrame.right - frame.right, 0);</a>
<a name="ln1666">		if (frame.top &lt; screenFrame.top)</a>
<a name="ln1667">			frame.OffsetBy(screenFrame.top - frame.top, 0);</a>
<a name="ln1668">		else if (frame.bottom &gt; screenFrame.bottom)</a>
<a name="ln1669">			frame.OffsetBy(screenFrame.bottom - frame.bottom, 0);</a>
<a name="ln1670">	}</a>
<a name="ln1671"> </a>
<a name="ln1672">	MoveTo(frame.left, frame.top);</a>
<a name="ln1673">	ResizeTo(width, height);</a>
<a name="ln1674">}</a>
<a name="ln1675"> </a>
<a name="ln1676"> </a>
<a name="ln1677">void</a>
<a name="ln1678">BrowserWindow::SetToolBarsVisible(bool flag, BWebView* view)</a>
<a name="ln1679">{</a>
<a name="ln1680">	// TODO</a>
<a name="ln1681">	// TODO: Ignore request when there is more than one BWebView embedded!</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684"> </a>
<a name="ln1685">void</a>
<a name="ln1686">BrowserWindow::SetStatusBarVisible(bool flag, BWebView* view)</a>
<a name="ln1687">{</a>
<a name="ln1688">	// TODO</a>
<a name="ln1689">	// TODO: Ignore request when there is more than one BWebView embedded!</a>
<a name="ln1690">}</a>
<a name="ln1691"> </a>
<a name="ln1692"> </a>
<a name="ln1693">void</a>
<a name="ln1694">BrowserWindow::SetMenuBarVisible(bool flag, BWebView* view)</a>
<a name="ln1695">{</a>
<a name="ln1696">	// TODO</a>
<a name="ln1697">	// TODO: Ignore request when there is more than one BWebView embedded!</a>
<a name="ln1698">}</a>
<a name="ln1699"> </a>
<a name="ln1700"> </a>
<a name="ln1701">void</a>
<a name="ln1702">BrowserWindow::SetResizable(bool flag, BWebView* view)</a>
<a name="ln1703">{</a>
<a name="ln1704">	// TODO: Ignore request when there is more than one BWebView embedded!</a>
<a name="ln1705"> </a>
<a name="ln1706">	if (flag)</a>
<a name="ln1707">		SetFlags(Flags() &amp; ~B_NOT_RESIZABLE);</a>
<a name="ln1708">	else</a>
<a name="ln1709">		SetFlags(Flags() | B_NOT_RESIZABLE);</a>
<a name="ln1710">}</a>
<a name="ln1711"> </a>
<a name="ln1712"> </a>
<a name="ln1713">void</a>
<a name="ln1714">BrowserWindow::StatusChanged(const BString&amp; statusText, BWebView* view)</a>
<a name="ln1715">{</a>
<a name="ln1716">	if (view != CurrentWebView())</a>
<a name="ln1717">		return;</a>
<a name="ln1718"> </a>
<a name="ln1719">	if (fStatusText)</a>
<a name="ln1720">		fStatusText-&gt;SetText(statusText.String());</a>
<a name="ln1721">}</a>
<a name="ln1722"> </a>
<a name="ln1723"> </a>
<a name="ln1724">void</a>
<a name="ln1725">BrowserWindow::NavigationCapabilitiesChanged(bool canGoBackward,</a>
<a name="ln1726">	bool canGoForward, bool canStop, BWebView* view)</a>
<a name="ln1727">{</a>
<a name="ln1728">	if (view != CurrentWebView())</a>
<a name="ln1729">		return;</a>
<a name="ln1730"> </a>
<a name="ln1731">	fBackButton-&gt;SetEnabled(canGoBackward);</a>
<a name="ln1732">	fForwardButton-&gt;SetEnabled(canGoForward);</a>
<a name="ln1733">	fStopButton-&gt;SetEnabled(canStop);</a>
<a name="ln1734"> </a>
<a name="ln1735">	fBackMenuItem-&gt;SetEnabled(canGoBackward);</a>
<a name="ln1736">	fForwardMenuItem-&gt;SetEnabled(canGoForward);</a>
<a name="ln1737">}</a>
<a name="ln1738"> </a>
<a name="ln1739"> </a>
<a name="ln1740">void</a>
<a name="ln1741">BrowserWindow::UpdateGlobalHistory(const BString&amp; url)</a>
<a name="ln1742">{</a>
<a name="ln1743">	BrowsingHistory::DefaultInstance()-&gt;AddItem(BrowsingHistoryItem(url));</a>
<a name="ln1744"> </a>
<a name="ln1745">	fURLInputGroup-&gt;SetText(CurrentWebView()-&gt;MainFrameURL());</a>
<a name="ln1746">}</a>
<a name="ln1747"> </a>
<a name="ln1748"> </a>
<a name="ln1749">bool</a>
<a name="ln1750">BrowserWindow::AuthenticationChallenge(BString message, BString&amp; inOutUser,</a>
<a name="ln1751">	BString&amp; inOutPassword, bool&amp; inOutRememberCredentials,</a>
<a name="ln1752">	uint32 failureCount, BWebView* view)</a>
<a name="ln1753">{</a>
<a name="ln1754">	CredentialsStorage* persistentStorage</a>
<a name="ln1755">		= CredentialsStorage::PersistentInstance();</a>
<a name="ln1756">	CredentialsStorage* sessionStorage</a>
<a name="ln1757">		= CredentialsStorage::SessionInstance();</a>
<a name="ln1758"> </a>
<a name="ln1759">	// TODO: Using the message as key here is not so smart.</a>
<a name="ln1760">	HashKeyString key(message);</a>
<a name="ln1761"> </a>
<a name="ln1762">	if (failureCount == 0) {</a>
<a name="ln1763">		if (persistentStorage-&gt;Contains(key)) {</a>
<a name="ln1764">			Credentials credentials = persistentStorage-&gt;GetCredentials(key);</a>
<a name="ln1765">			inOutUser = credentials.Username();</a>
<a name="ln1766">			inOutPassword = credentials.Password();</a>
<a name="ln1767">			return true;</a>
<a name="ln1768">		} else if (sessionStorage-&gt;Contains(key)) {</a>
<a name="ln1769">			Credentials credentials = sessionStorage-&gt;GetCredentials(key);</a>
<a name="ln1770">			inOutUser = credentials.Username();</a>
<a name="ln1771">			inOutPassword = credentials.Password();</a>
<a name="ln1772">			return true;</a>
<a name="ln1773">		}</a>
<a name="ln1774">	}</a>
<a name="ln1775">	// Switch to the page for which this authentication is required.</a>
<a name="ln1776">	if (!_ShowPage(view))</a>
<a name="ln1777">		return false;</a>
<a name="ln1778"> </a>
<a name="ln1779">	AuthenticationPanel* panel = new AuthenticationPanel(Frame());</a>
<a name="ln1780">		// Panel auto-destructs.</a>
<a name="ln1781">	bool success = panel-&gt;getAuthentication(message, inOutUser, inOutPassword,</a>
<a name="ln1782">		inOutRememberCredentials, failureCount &gt; 0, inOutUser, inOutPassword,</a>
<a name="ln1783">		&amp;inOutRememberCredentials);</a>
<a name="ln1784">	if (success) {</a>
<a name="ln1785">		Credentials credentials(inOutUser, inOutPassword);</a>
<a name="ln1786">		if (inOutRememberCredentials)</a>
<a name="ln1787">			persistentStorage-&gt;PutCredentials(key, credentials);</a>
<a name="ln1788">		else</a>
<a name="ln1789">			sessionStorage-&gt;PutCredentials(key, credentials);</a>
<a name="ln1790">	}</a>
<a name="ln1791">	return success;</a>
<a name="ln1792">}</a>
<a name="ln1793"> </a>
<a name="ln1794"> </a>
<a name="ln1795">// #pragma mark - private</a>
<a name="ln1796"> </a>
<a name="ln1797"> </a>
<a name="ln1798">void</a>
<a name="ln1799">BrowserWindow::_UpdateTitle(const BString&amp; title)</a>
<a name="ln1800">{</a>
<a name="ln1801">	BString windowTitle;</a>
<a name="ln1802"> </a>
<a name="ln1803">	if (title.Length() &gt; 0)</a>
<a name="ln1804">		windowTitle = title;</a>
<a name="ln1805">	else {</a>
<a name="ln1806">		BWebView* webView = CurrentWebView();</a>
<a name="ln1807">		if (webView != NULL) {</a>
<a name="ln1808">			BString url = webView-&gt;MainFrameURL();</a>
<a name="ln1809">			int32 leafPos = url.FindLast('/');</a>
<a name="ln1810">			url.Remove(0, leafPos + 1);</a>
<a name="ln1811">			windowTitle = url;</a>
<a name="ln1812">		}</a>
<a name="ln1813">	}</a>
<a name="ln1814"> </a>
<a name="ln1815">	if (windowTitle.Length() &gt; 0)</a>
<a name="ln1816">		windowTitle &lt;&lt; &quot; - &quot;;</a>
<a name="ln1817">	windowTitle &lt;&lt; kApplicationName;</a>
<a name="ln1818">	SetTitle(windowTitle.String());</a>
<a name="ln1819">}</a>
<a name="ln1820"> </a>
<a name="ln1821"> </a>
<a name="ln1822">void</a>
<a name="ln1823">BrowserWindow::_UpdateTabGroupVisibility()</a>
<a name="ln1824">{</a>
<a name="ln1825">	if (Lock()) {</a>
<a name="ln1826">		if (fInterfaceVisible)</a>
<a name="ln1827">			fTabGroup-&gt;SetVisible(_TabGroupShouldBeVisible());</a>
<a name="ln1828">		fTabManager-&gt;SetCloseButtonsAvailable(fTabManager-&gt;CountTabs() &gt; 1);</a>
<a name="ln1829">		Unlock();</a>
<a name="ln1830">	}</a>
<a name="ln1831">}</a>
<a name="ln1832"> </a>
<a name="ln1833"> </a>
<a name="ln1834">bool</a>
<a name="ln1835">BrowserWindow::_TabGroupShouldBeVisible() const</a>
<a name="ln1836">{</a>
<a name="ln1837">	return (fShowTabsIfSinglePageOpen || fTabManager-&gt;CountTabs() &gt; 1)</a>
<a name="ln1838">		&amp;&amp; (fVisibleInterfaceElements &amp; INTERFACE_ELEMENT_TABS) != 0;</a>
<a name="ln1839">}</a>
<a name="ln1840"> </a>
<a name="ln1841"> </a>
<a name="ln1842">void</a>
<a name="ln1843">BrowserWindow::_ShutdownTab(int32 index)</a>
<a name="ln1844">{</a>
<a name="ln1845">	BView* view = fTabManager-&gt;RemoveTab(index);</a>
<a name="ln1846">	BWebView* webView = dynamic_cast&lt;BWebView*&gt;(view);</a>
<a name="ln1847">	if (webView == CurrentWebView())</a>
<a name="ln1848">		SetCurrentWebView(NULL);</a>
<a name="ln1849">	if (webView != NULL)</a>
<a name="ln1850">		webView-&gt;Shutdown();</a>
<a name="ln1851">	else</a>
<a name="ln1852">		delete view;</a>
<a name="ln1853">}</a>
<a name="ln1854"> </a>
<a name="ln1855"> </a>
<a name="ln1856">void</a>
<a name="ln1857">BrowserWindow::_TabChanged(int32 index)</a>
<a name="ln1858">{</a>
<a name="ln1859">	SetCurrentWebView(dynamic_cast&lt;BWebView*&gt;(fTabManager-&gt;ViewForTab(index)));</a>
<a name="ln1860">}</a>
<a name="ln1861"> </a>
<a name="ln1862"> </a>
<a name="ln1863">status_t</a>
<a name="ln1864">BrowserWindow::_BookmarkPath(BPath&amp; path) const</a>
<a name="ln1865">{</a>
<a name="ln1866">	status_t ret = find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path);</a>
<a name="ln1867">	if (ret != B_OK)</a>
<a name="ln1868">		return ret;</a>
<a name="ln1869"> </a>
<a name="ln1870">	ret = path.Append(kApplicationName);</a>
<a name="ln1871">	if (ret != B_OK)</a>
<a name="ln1872">		return ret;</a>
<a name="ln1873"> </a>
<a name="ln1874">	ret = path.Append(&quot;Bookmarks&quot;);</a>
<a name="ln1875">	if (ret != B_OK)</a>
<a name="ln1876">		return ret;</a>
<a name="ln1877"> </a>
<a name="ln1878">	return create_directory(path.Path(), 0777);</a>
<a name="ln1879">}</a>
<a name="ln1880"> </a>
<a name="ln1881"> </a>
<a name="ln1882">void</a>
<a name="ln1883">BrowserWindow::_CreateBookmark()</a>
<a name="ln1884">{</a>
<a name="ln1885">	BPath path;</a>
<a name="ln1886">	status_t status = _BookmarkPath(path);</a>
<a name="ln1887">	if (status != B_OK) {</a>
<a name="ln1888">		BString message(B_TRANSLATE_COMMENT(&quot;There was an error retrieving &quot;</a>
<a name="ln1889">			&quot;the bookmark folder.\n\nError: %error&quot;, &quot;Don't translate the &quot;</a>
<a name="ln1890">			&quot;variable %error&quot;));</a>
<a name="ln1891">		message.ReplaceFirst(&quot;%error&quot;, strerror(status));</a>
<a name="ln1892">		BAlert* alert = new BAlert(B_TRANSLATE(&quot;Bookmark error&quot;),</a>
<a name="ln1893">			message.String(), B_TRANSLATE(&quot;OK&quot;), NULL, NULL,</a>
<a name="ln1894">			B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln1895">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1896">		alert-&gt;Go();</a>
<a name="ln1897">		return;</a>
<a name="ln1898">	}</a>
<a name="ln1899">	BWebView* webView = CurrentWebView();</a>
<a name="ln1900">	BString url(webView-&gt;MainFrameURL());</a>
<a name="ln1901">	// Create a bookmark file</a>
<a name="ln1902">	BFile bookmarkFile;</a>
<a name="ln1903">	BString bookmarkName(webView-&gt;MainFrameTitle());</a>
<a name="ln1904">	if (bookmarkName.Length() == 0) {</a>
<a name="ln1905">		bookmarkName = url;</a>
<a name="ln1906">		int32 leafPos = bookmarkName.FindLast('/');</a>
<a name="ln1907">		if (leafPos &gt;= 0)</a>
<a name="ln1908">			bookmarkName.Remove(0, leafPos + 1);</a>
<a name="ln1909">	}</a>
<a name="ln1910">	// Make sure the bookmark title does not contain chars that are not</a>
<a name="ln1911">	// allowed in file names, and is within allowed name length.</a>
<a name="ln1912">	bookmarkName.ReplaceAll('/', '-');</a>
<a name="ln1913">	bookmarkName.Truncate(B_FILE_NAME_LENGTH - 1);</a>
<a name="ln1914"> </a>
<a name="ln1915">	// Check that the bookmark exists nowhere in the bookmark hierarchy,</a>
<a name="ln1916">	// though the intended file name must match, we don't search the stored</a>
<a name="ln1917">	// URLs, only for matching file names.</a>
<a name="ln1918">	BDirectory directory(path.Path());</a>
<a name="ln1919">	if (status == B_OK &amp;&amp; _CheckBookmarkExists(directory, bookmarkName, url)) {</a>
<a name="ln1920">		BString message(B_TRANSLATE_COMMENT(&quot;A bookmark for this page &quot;</a>
<a name="ln1921">			&quot;(%bookmarkName) already exists.&quot;, &quot;Don't translate variable &quot;</a>
<a name="ln1922">			&quot;%bookmarkName&quot;));</a>
<a name="ln1923">		message.ReplaceFirst(&quot;%bookmarkName&quot;, bookmarkName);</a>
<a name="ln1924">		BAlert* alert = new BAlert(B_TRANSLATE(&quot;Bookmark info&quot;),</a>
<a name="ln1925">			message.String(), B_TRANSLATE(&quot;OK&quot;));</a>
<a name="ln1926">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1927">		alert-&gt;Go();</a>
<a name="ln1928">		return;</a>
<a name="ln1929">	}</a>
<a name="ln1930"> </a>
<a name="ln1931">	BPath entryPath(path);</a>
<a name="ln1932">	status = entryPath.Append(bookmarkName);</a>
<a name="ln1933">	BEntry entry;</a>
<a name="ln1934">	if (status == B_OK)</a>
<a name="ln1935">		status = entry.SetTo(entryPath.Path(), true);</a>
<a name="ln1936">	if (status == B_OK) {</a>
<a name="ln1937">		int32 tries = 1;</a>
<a name="ln1938">		while (entry.Exists()) {</a>
<a name="ln1939">			// Find a unique name for the bookmark, there may still be a</a>
<a name="ln1940">			// file in the way that stores a different URL.</a>
<a name="ln1941">			bookmarkName = webView-&gt;MainFrameTitle();</a>
<a name="ln1942">			bookmarkName &lt;&lt; &quot; &quot; &lt;&lt; tries++;</a>
<a name="ln1943">			entryPath = path;</a>
<a name="ln1944">			status = entryPath.Append(bookmarkName);</a>
<a name="ln1945">			if (status == B_OK)</a>
<a name="ln1946">				status = entry.SetTo(entryPath.Path(), true);</a>
<a name="ln1947">			if (status != B_OK)</a>
<a name="ln1948">				break;</a>
<a name="ln1949">		}</a>
<a name="ln1950">	}</a>
<a name="ln1951">	if (status == B_OK) {</a>
<a name="ln1952">		status = bookmarkFile.SetTo(&amp;entry,</a>
<a name="ln1953">			B_CREATE_FILE | B_ERASE_FILE | B_WRITE_ONLY);</a>
<a name="ln1954">	}</a>
<a name="ln1955"> </a>
<a name="ln1956">	// Write bookmark meta data</a>
<a name="ln1957">	if (status == B_OK)</a>
<a name="ln1958">		status = bookmarkFile.WriteAttrString(&quot;META:url&quot;, &amp;url);</a>
<a name="ln1959">	if (status == B_OK) {</a>
<a name="ln1960">		BString title = webView-&gt;MainFrameTitle();</a>
<a name="ln1961">		bookmarkFile.WriteAttrString(&quot;META:title&quot;, &amp;title);</a>
<a name="ln1962">	}</a>
<a name="ln1963"> </a>
<a name="ln1964">	BNodeInfo nodeInfo(&amp;bookmarkFile);</a>
<a name="ln1965">	if (status == B_OK) {</a>
<a name="ln1966">		status = nodeInfo.SetType(&quot;application/x-vnd.Be-bookmark&quot;);</a>
<a name="ln1967">		if (status == B_OK) {</a>
<a name="ln1968">			PageUserData* userData = static_cast&lt;PageUserData*&gt;(</a>
<a name="ln1969">				webView-&gt;GetUserData());</a>
<a name="ln1970">			if (userData != NULL &amp;&amp; userData-&gt;PageIcon() != NULL) {</a>
<a name="ln1971">				BBitmap miniIcon(BRect(0, 0, 15, 15), B_BITMAP_NO_SERVER_LINK,</a>
<a name="ln1972">					B_CMAP8);</a>
<a name="ln1973">				status_t ret = miniIcon.ImportBits(userData-&gt;PageIcon());</a>
<a name="ln1974">				if (ret == B_OK)</a>
<a name="ln1975">					ret = nodeInfo.SetIcon(&amp;miniIcon, B_MINI_ICON);</a>
<a name="ln1976">				if (ret != B_OK) {</a>
<a name="ln1977">					fprintf(stderr, &quot;Failed to store mini icon for bookmark: &quot;</a>
<a name="ln1978">						&quot;%s\n&quot;, strerror(ret));</a>
<a name="ln1979">				}</a>
<a name="ln1980">				BBitmap largeIcon(BRect(0, 0, 31, 31), B_BITMAP_NO_SERVER_LINK,</a>
<a name="ln1981">					B_CMAP8);</a>
<a name="ln1982">				// TODO: Store 32x32 favicon which is often provided by sites.</a>
<a name="ln1983">				const uint8* src = (const uint8*)miniIcon.Bits();</a>
<a name="ln1984">				uint32 srcBPR = miniIcon.BytesPerRow();</a>
<a name="ln1985">				uint8* dst = (uint8*)largeIcon.Bits();</a>
<a name="ln1986">				uint32 dstBPR = largeIcon.BytesPerRow();</a>
<a name="ln1987">				for (uint32 y = 0; y &lt; 16; y++) {</a>
<a name="ln1988">					const uint8* s = src;</a>
<a name="ln1989">					uint8* d = dst;</a>
<a name="ln1990">					for (uint32 x = 0; x &lt; 16; x++) {</a>
<a name="ln1991">						*d++ = *s;</a>
<a name="ln1992">						*d++ = *s++;</a>
<a name="ln1993">					}</a>
<a name="ln1994">					dst += dstBPR;</a>
<a name="ln1995">					s = src;</a>
<a name="ln1996">					for (uint32 x = 0; x &lt; 16; x++) {</a>
<a name="ln1997">						*d++ = *s;</a>
<a name="ln1998">						*d++ = *s++;</a>
<a name="ln1999">					}</a>
<a name="ln2000">					dst += dstBPR;</a>
<a name="ln2001">					src += srcBPR;</a>
<a name="ln2002">				}</a>
<a name="ln2003">				if (ret == B_OK)</a>
<a name="ln2004">					ret = nodeInfo.SetIcon(&amp;largeIcon, B_LARGE_ICON);</a>
<a name="ln2005">				if (ret != B_OK) {</a>
<a name="ln2006">					fprintf(stderr, &quot;Failed to store large icon for bookmark: &quot;</a>
<a name="ln2007">						&quot;%s\n&quot;, strerror(ret));</a>
<a name="ln2008">				}</a>
<a name="ln2009">			}</a>
<a name="ln2010">		}</a>
<a name="ln2011">	}</a>
<a name="ln2012"> </a>
<a name="ln2013">	if (status != B_OK) {</a>
<a name="ln2014">		BString message(B_TRANSLATE_COMMENT(&quot;There was an error creating the &quot;</a>
<a name="ln2015">			&quot;bookmark file.\n\nError: %error&quot;, &quot;Don't translate variable &quot;</a>
<a name="ln2016">			&quot;%error&quot;));</a>
<a name="ln2017">		message.ReplaceFirst(&quot;%error&quot;, strerror(status));</a>
<a name="ln2018">		BAlert* alert = new BAlert(B_TRANSLATE(&quot;Bookmark error&quot;),</a>
<a name="ln2019">			message.String(), B_TRANSLATE(&quot;OK&quot;), NULL, NULL,</a>
<a name="ln2020">			B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln2021">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2022">		alert-&gt;Go();</a>
<a name="ln2023">		return;</a>
<a name="ln2024">	}</a>
<a name="ln2025">}</a>
<a name="ln2026"> </a>
<a name="ln2027"> </a>
<a name="ln2028">void</a>
<a name="ln2029">BrowserWindow::_ShowBookmarks()</a>
<a name="ln2030">{</a>
<a name="ln2031">	BPath path;</a>
<a name="ln2032">	entry_ref ref;</a>
<a name="ln2033">	status_t status = _BookmarkPath(path);</a>
<a name="ln2034">	if (status == B_OK)</a>
<a name="ln2035">		status = get_ref_for_path(path.Path(), &amp;ref);</a>
<a name="ln2036">	if (status == B_OK)</a>
<a name="ln2037">		status = be_roster-&gt;Launch(&amp;ref);</a>
<a name="ln2038"> </a>
<a name="ln2039">	if (status != B_OK &amp;&amp; status != B_ALREADY_RUNNING) {</a>
<a name="ln2040">		BString message(B_TRANSLATE_COMMENT(&quot;There was an error trying to &quot;</a>
<a name="ln2041">			&quot;show the Bookmarks folder.\n\nError: %error&quot;,</a>
<a name="ln2042">			&quot;Don't translate variable %error&quot;));</a>
<a name="ln2043">		message.ReplaceFirst(&quot;%error&quot;, strerror(status));</a>
<a name="ln2044">		BAlert* alert = new BAlert(B_TRANSLATE(&quot;Bookmark error&quot;),</a>
<a name="ln2045">			message.String(), B_TRANSLATE(&quot;OK&quot;), NULL, NULL,</a>
<a name="ln2046">			B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln2047">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2048">		alert-&gt;Go();</a>
<a name="ln2049">		return;</a>
<a name="ln2050">	}</a>
<a name="ln2051">}</a>
<a name="ln2052"> </a>
<a name="ln2053"> </a>
<a name="ln2054">bool BrowserWindow::_CheckBookmarkExists(BDirectory&amp; directory,</a>
<a name="ln2055">	const BString&amp; bookmarkName, const BString&amp; url) const</a>
<a name="ln2056">{</a>
<a name="ln2057">	BEntry entry;</a>
<a name="ln2058">	while (directory.GetNextEntry(&amp;entry) == B_OK) {</a>
<a name="ln2059">		if (entry.IsDirectory()) {</a>
<a name="ln2060">			BDirectory subBirectory(&amp;entry);</a>
<a name="ln2061">			// At least preserve the entry file handle when recursing into</a>
<a name="ln2062">			// sub-folders... eventually we will run out, though, with very</a>
<a name="ln2063">			// deep hierarchy.</a>
<a name="ln2064">			entry.Unset();</a>
<a name="ln2065">			if (_CheckBookmarkExists(subBirectory, bookmarkName, url))</a>
<a name="ln2066">				return true;</a>
<a name="ln2067">		} else {</a>
<a name="ln2068">			char entryName[B_FILE_NAME_LENGTH];</a>
<a name="ln2069">			if (entry.GetName(entryName) != B_OK || bookmarkName != entryName)</a>
<a name="ln2070">				continue;</a>
<a name="ln2071">			BString storedURL;</a>
<a name="ln2072">			BFile file(&amp;entry, B_READ_ONLY);</a>
<a name="ln2073">			if (_ReadURLAttr(file, storedURL)) {</a>
<a name="ln2074">				// Just bail if the bookmark already exists</a>
<a name="ln2075">				if (storedURL == url)</a>
<a name="ln2076">					return true;</a>
<a name="ln2077">			}</a>
<a name="ln2078">		}</a>
<a name="ln2079">	}</a>
<a name="ln2080">	return false;</a>
<a name="ln2081">}</a>
<a name="ln2082"> </a>
<a name="ln2083"> </a>
<a name="ln2084">bool</a>
<a name="ln2085">BrowserWindow::_ReadURLAttr(BFile&amp; bookmarkFile, BString&amp; url) const</a>
<a name="ln2086">{</a>
<a name="ln2087">	return bookmarkFile.InitCheck() == B_OK</a>
<a name="ln2088">		&amp;&amp; bookmarkFile.ReadAttrString(&quot;META:url&quot;, &amp;url) == B_OK;</a>
<a name="ln2089">}</a>
<a name="ln2090"> </a>
<a name="ln2091"> </a>
<a name="ln2092">void</a>
<a name="ln2093">BrowserWindow::_AddBookmarkURLsRecursively(BDirectory&amp; directory,</a>
<a name="ln2094">	BMessage* message, uint32&amp; addedCount) const</a>
<a name="ln2095">{</a>
<a name="ln2096">	BEntry entry;</a>
<a name="ln2097">	while (directory.GetNextEntry(&amp;entry) == B_OK) {</a>
<a name="ln2098">		if (entry.IsDirectory()) {</a>
<a name="ln2099">			BDirectory subBirectory(&amp;entry);</a>
<a name="ln2100">			// At least preserve the entry file handle when recursing into</a>
<a name="ln2101">			// sub-folders... eventually we will run out, though, with very</a>
<a name="ln2102">			// deep hierarchy.</a>
<a name="ln2103">			entry.Unset();</a>
<a name="ln2104">			_AddBookmarkURLsRecursively(subBirectory, message, addedCount);</a>
<a name="ln2105">		} else {</a>
<a name="ln2106">			BString storedURL;</a>
<a name="ln2107">			BFile file(&amp;entry, B_READ_ONLY);</a>
<a name="ln2108">			if (_ReadURLAttr(file, storedURL)) {</a>
<a name="ln2109">				message-&gt;AddString(&quot;url&quot;, storedURL.String());</a>
<a name="ln2110">				addedCount++;</a>
<a name="ln2111">			}</a>
<a name="ln2112">		}</a>
<a name="ln2113">	}</a>
<a name="ln2114">}</a>
<a name="ln2115"> </a>
<a name="ln2116"> </a>
<a name="ln2117">void</a>
<a name="ln2118">BrowserWindow::_SetPageIcon(BWebView* view, const BBitmap* icon)</a>
<a name="ln2119">{</a>
<a name="ln2120">	PageUserData* userData = static_cast&lt;PageUserData*&gt;(view-&gt;GetUserData());</a>
<a name="ln2121">	if (userData == NULL) {</a>
<a name="ln2122">		userData = new(std::nothrow) PageUserData(NULL);</a>
<a name="ln2123">		if (userData == NULL)</a>
<a name="ln2124">			return;</a>
<a name="ln2125">		view-&gt;SetUserData(userData);</a>
<a name="ln2126">	}</a>
<a name="ln2127">	// The PageUserData makes a copy of the icon, which we pass on to</a>
<a name="ln2128">	// the TabManager for display in the respective tab.</a>
<a name="ln2129">	userData-&gt;SetPageIcon(icon);</a>
<a name="ln2130">	fTabManager-&gt;SetTabIcon(view, userData-&gt;PageIcon());</a>
<a name="ln2131">	if (view == CurrentWebView())</a>
<a name="ln2132">		fURLInputGroup-&gt;SetPageIcon(icon);</a>
<a name="ln2133">}</a>
<a name="ln2134"> </a>
<a name="ln2135"> </a>
<a name="ln2136">static void</a>
<a name="ln2137">addItemToMenuOrSubmenu(BMenu* menu, BMenuItem* newItem)</a>
<a name="ln2138">{</a>
<a name="ln2139">	BString baseURLLabel = baseURL(BString(newItem-&gt;Label()));</a>
<a name="ln2140">	for (int32 i = menu-&gt;CountItems() - 1; i &gt;= 0; i--) {</a>
<a name="ln2141">		BMenuItem* item = menu-&gt;ItemAt(i);</a>
<a name="ln2142">		BString label = item-&gt;Label();</a>
<a name="ln2143">		if (label.FindFirst(baseURLLabel) &gt;= 0) {</a>
<a name="ln2144">			if (item-&gt;Submenu()) {</a>
<a name="ln2145">				// Submenu was already added in previous iteration.</a>
<a name="ln2146">				item-&gt;Submenu()-&gt;AddItem(newItem);</a>
<a name="ln2147">				return;</a>
<a name="ln2148">			} else {</a>
<a name="ln2149">				menu-&gt;RemoveItem(item);</a>
<a name="ln2150">				BMenu* subMenu = new BMenu(baseURLLabel.String());</a>
<a name="ln2151">				subMenu-&gt;AddItem(item);</a>
<a name="ln2152">				subMenu-&gt;AddItem(newItem);</a>
<a name="ln2153">				// Add common submenu for this base URL, clickable.</a>
<a name="ln2154">				BMessage* message = new BMessage(GOTO_URL);</a>
<a name="ln2155">				message-&gt;AddString(&quot;url&quot;, baseURLLabel.String());</a>
<a name="ln2156">				menu-&gt;AddItem(new BMenuItem(subMenu, message), i);</a>
<a name="ln2157">				return;</a>
<a name="ln2158">			}</a>
<a name="ln2159">		}</a>
<a name="ln2160">	}</a>
<a name="ln2161">	menu-&gt;AddItem(newItem);</a>
<a name="ln2162">}</a>
<a name="ln2163"> </a>
<a name="ln2164"> </a>
<a name="ln2165">static void</a>
<a name="ln2166">addOrDeleteMenu(BMenu* menu, BMenu* toMenu)</a>
<a name="ln2167">{</a>
<a name="ln2168">	if (menu-&gt;CountItems() &gt; 0)</a>
<a name="ln2169">		toMenu-&gt;AddItem(menu);</a>
<a name="ln2170">	else</a>
<a name="ln2171">		delete menu;</a>
<a name="ln2172">}</a>
<a name="ln2173"> </a>
<a name="ln2174"> </a>
<a name="ln2175">void</a>
<a name="ln2176">BrowserWindow::_UpdateHistoryMenu()</a>
<a name="ln2177">{</a>
<a name="ln2178">	BMenuItem* menuItem;</a>
<a name="ln2179">	while ((menuItem = fHistoryMenu-&gt;RemoveItem(fHistoryMenuFixedItemCount)))</a>
<a name="ln2180">		delete menuItem;</a>
<a name="ln2181"> </a>
<a name="ln2182">	BrowsingHistory* history = BrowsingHistory::DefaultInstance();</a>
<a name="ln2183">	if (!history-&gt;Lock())</a>
<a name="ln2184">		return;</a>
<a name="ln2185"> </a>
<a name="ln2186">	int32 count = history-&gt;CountItems();</a>
<a name="ln2187">	BMenuItem* clearHistoryItem = new BMenuItem(B_TRANSLATE(&quot;Clear history&quot;),</a>
<a name="ln2188">		new BMessage(CLEAR_HISTORY));</a>
<a name="ln2189">	clearHistoryItem-&gt;SetEnabled(count &gt; 0);</a>
<a name="ln2190">	fHistoryMenu-&gt;AddItem(clearHistoryItem);</a>
<a name="ln2191">	if (count == 0) {</a>
<a name="ln2192">		history-&gt;Unlock();</a>
<a name="ln2193">		return;</a>
<a name="ln2194">	}</a>
<a name="ln2195">	fHistoryMenu-&gt;AddSeparatorItem();</a>
<a name="ln2196"> </a>
<a name="ln2197">	BDateTime todayStart = BDateTime::CurrentDateTime(B_LOCAL_TIME);</a>
<a name="ln2198">	todayStart.SetTime(BTime(0, 0, 0));</a>
<a name="ln2199"> </a>
<a name="ln2200">	BDateTime oneDayAgoStart = todayStart;</a>
<a name="ln2201">	oneDayAgoStart.Date().AddDays(-1);</a>
<a name="ln2202"> </a>
<a name="ln2203">	BDateTime twoDaysAgoStart = oneDayAgoStart;</a>
<a name="ln2204">	twoDaysAgoStart.Date().AddDays(-1);</a>
<a name="ln2205"> </a>
<a name="ln2206">	BDateTime threeDaysAgoStart = twoDaysAgoStart;</a>
<a name="ln2207">	threeDaysAgoStart.Date().AddDays(-1);</a>
<a name="ln2208"> </a>
<a name="ln2209">	BDateTime fourDaysAgoStart = threeDaysAgoStart;</a>
<a name="ln2210">	fourDaysAgoStart.Date().AddDays(-1);</a>
<a name="ln2211"> </a>
<a name="ln2212">	BDateTime fiveDaysAgoStart = fourDaysAgoStart;</a>
<a name="ln2213">	fiveDaysAgoStart.Date().AddDays(-1);</a>
<a name="ln2214"> </a>
<a name="ln2215">	BMenu* todayMenu = new BMenu(B_TRANSLATE(&quot;Today&quot;));</a>
<a name="ln2216">	BMenu* yesterdayMenu = new BMenu(B_TRANSLATE(&quot;Yesterday&quot;));</a>
<a name="ln2217">	BMenu* twoDaysAgoMenu = new BMenu(</a>
<a name="ln2218">		twoDaysAgoStart.Date().LongDayName().String());</a>
<a name="ln2219">	BMenu* threeDaysAgoMenu = new BMenu(</a>
<a name="ln2220">		threeDaysAgoStart.Date().LongDayName().String());</a>
<a name="ln2221">	BMenu* fourDaysAgoMenu = new BMenu(</a>
<a name="ln2222">		fourDaysAgoStart.Date().LongDayName().String());</a>
<a name="ln2223">	BMenu* fiveDaysAgoMenu = new BMenu(</a>
<a name="ln2224">		fiveDaysAgoStart.Date().LongDayName().String());</a>
<a name="ln2225">	BMenu* earlierMenu = new BMenu(B_TRANSLATE(&quot;Earlier&quot;));</a>
<a name="ln2226"> </a>
<a name="ln2227">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2228">		BrowsingHistoryItem historyItem = history-&gt;HistoryItemAt(i);</a>
<a name="ln2229">		BMessage* message = new BMessage(GOTO_URL);</a>
<a name="ln2230">		message-&gt;AddString(&quot;url&quot;, historyItem.URL().String());</a>
<a name="ln2231"> </a>
<a name="ln2232">		BString truncatedUrl(historyItem.URL());</a>
<a name="ln2233">		be_plain_font-&gt;TruncateString(&amp;truncatedUrl, B_TRUNCATE_END, 480);</a>
<a name="ln2234">		menuItem = new BMenuItem(truncatedUrl, message);</a>
<a name="ln2235"> </a>
<a name="ln2236">		if (historyItem.DateTime() &lt; fiveDaysAgoStart)</a>
<a name="ln2237">			addItemToMenuOrSubmenu(earlierMenu, menuItem);</a>
<a name="ln2238">		else if (historyItem.DateTime() &lt; fourDaysAgoStart)</a>
<a name="ln2239">			addItemToMenuOrSubmenu(fiveDaysAgoMenu, menuItem);</a>
<a name="ln2240">		else if (historyItem.DateTime() &lt; threeDaysAgoStart)</a>
<a name="ln2241">			addItemToMenuOrSubmenu(fourDaysAgoMenu, menuItem);</a>
<a name="ln2242">		else if (historyItem.DateTime() &lt; twoDaysAgoStart)</a>
<a name="ln2243">			addItemToMenuOrSubmenu(threeDaysAgoMenu, menuItem);</a>
<a name="ln2244">		else if (historyItem.DateTime() &lt; oneDayAgoStart)</a>
<a name="ln2245">			addItemToMenuOrSubmenu(twoDaysAgoMenu, menuItem);</a>
<a name="ln2246">		else if (historyItem.DateTime() &lt; todayStart)</a>
<a name="ln2247">			addItemToMenuOrSubmenu(yesterdayMenu, menuItem);</a>
<a name="ln2248">		else</a>
<a name="ln2249">			addItemToMenuOrSubmenu(todayMenu, menuItem);</a>
<a name="ln2250">	}</a>
<a name="ln2251">	history-&gt;Unlock();</a>
<a name="ln2252"> </a>
<a name="ln2253">	addOrDeleteMenu(todayMenu, fHistoryMenu);</a>
<a name="ln2254">	addOrDeleteMenu(yesterdayMenu, fHistoryMenu);</a>
<a name="ln2255">	addOrDeleteMenu(twoDaysAgoMenu, fHistoryMenu);</a>
<a name="ln2256">	addOrDeleteMenu(threeDaysAgoMenu, fHistoryMenu);</a>
<a name="ln2257">	addOrDeleteMenu(fourDaysAgoMenu, fHistoryMenu);</a>
<a name="ln2258">	addOrDeleteMenu(fiveDaysAgoMenu, fHistoryMenu);</a>
<a name="ln2259">	addOrDeleteMenu(earlierMenu, fHistoryMenu);</a>
<a name="ln2260">}</a>
<a name="ln2261"> </a>
<a name="ln2262"> </a>
<a name="ln2263">void</a>
<a name="ln2264">BrowserWindow::_UpdateClipboardItems()</a>
<a name="ln2265">{</a>
<a name="ln2266">	BTextView* focusTextView = dynamic_cast&lt;BTextView*&gt;(CurrentFocus());</a>
<a name="ln2267">	if (focusTextView != NULL) {</a>
<a name="ln2268">		int32 selectionStart;</a>
<a name="ln2269">		int32 selectionEnd;</a>
<a name="ln2270">		focusTextView-&gt;GetSelection(&amp;selectionStart, &amp;selectionEnd);</a>
<a name="ln2271">		bool hasSelection = selectionStart &lt; selectionEnd;</a>
<a name="ln2272">		bool canPaste = false;</a>
<a name="ln2273">		// A BTextView has the focus.</a>
<a name="ln2274">		if (be_clipboard-&gt;Lock()) {</a>
<a name="ln2275">			BMessage* data = be_clipboard-&gt;Data();</a>
<a name="ln2276">			if (data != NULL)</a>
<a name="ln2277">				canPaste = data-&gt;HasData(&quot;text/plain&quot;, B_MIME_TYPE);</a>
<a name="ln2278">			be_clipboard-&gt;Unlock();</a>
<a name="ln2279">		}</a>
<a name="ln2280">		fCutMenuItem-&gt;SetEnabled(hasSelection);</a>
<a name="ln2281">		fCopyMenuItem-&gt;SetEnabled(hasSelection);</a>
<a name="ln2282">		fPasteMenuItem-&gt;SetEnabled(canPaste);</a>
<a name="ln2283">	} else if (CurrentWebView() != NULL) {</a>
<a name="ln2284">		// Trigger update of the clipboard items, even if the</a>
<a name="ln2285">		// BWebView doesn't have focus, we'll dispatch these message</a>
<a name="ln2286">		// there anyway. This works so fast that the user can never see</a>
<a name="ln2287">		// the wrong enabled state when the menu opens until the result</a>
<a name="ln2288">		// message arrives. The initial state needs to be enabled, since</a>
<a name="ln2289">		// standard shortcut handling is always wrapped inside MenusBeginning()</a>
<a name="ln2290">		// and MenusEnded(), and since we update items asynchronously, we need</a>
<a name="ln2291">		// to have them enabled to begin with.</a>
<a name="ln2292">		fCutMenuItem-&gt;SetEnabled(true);</a>
<a name="ln2293">		fCopyMenuItem-&gt;SetEnabled(true);</a>
<a name="ln2294">		fPasteMenuItem-&gt;SetEnabled(true);</a>
<a name="ln2295"> </a>
<a name="ln2296">		CurrentWebView()-&gt;WebPage()-&gt;SendEditingCapabilities();</a>
<a name="ln2297">	}</a>
<a name="ln2298">}</a>
<a name="ln2299"> </a>
<a name="ln2300"> </a>
<a name="ln2301">bool</a>
<a name="ln2302">BrowserWindow::_ShowPage(BWebView* view)</a>
<a name="ln2303">{</a>
<a name="ln2304">	if (view != CurrentWebView()) {</a>
<a name="ln2305">		int32 tabIndex = fTabManager-&gt;TabForView(view);</a>
<a name="ln2306">		if (tabIndex &lt; 0) {</a>
<a name="ln2307">			// Page seems to be gone already?</a>
<a name="ln2308">			return false;</a>
<a name="ln2309">		}</a>
<a name="ln2310">		fTabManager-&gt;SelectTab(tabIndex);</a>
<a name="ln2311">		_TabChanged(tabIndex);</a>
<a name="ln2312">		UpdateIfNeeded();</a>
<a name="ln2313">	}</a>
<a name="ln2314">	return true;</a>
<a name="ln2315">}</a>
<a name="ln2316"> </a>
<a name="ln2317"> </a>
<a name="ln2318">void</a>
<a name="ln2319">BrowserWindow::_ResizeToScreen()</a>
<a name="ln2320">{</a>
<a name="ln2321">	BScreen screen(this);</a>
<a name="ln2322">	MoveTo(0, 0);</a>
<a name="ln2323">	ResizeTo(screen.Frame().Width(), screen.Frame().Height());</a>
<a name="ln2324">}</a>
<a name="ln2325"> </a>
<a name="ln2326"> </a>
<a name="ln2327">void</a>
<a name="ln2328">BrowserWindow::_SetAutoHideInterfaceInFullscreen(bool doIt)</a>
<a name="ln2329">{</a>
<a name="ln2330">	if (fAutoHideInterfaceInFullscreenMode == doIt)</a>
<a name="ln2331">		return;</a>
<a name="ln2332"> </a>
<a name="ln2333">	fAutoHideInterfaceInFullscreenMode = doIt;</a>
<a name="ln2334">	if (fAppSettings-&gt;GetValue(kSettingsKeyAutoHideInterfaceInFullscreenMode,</a>
<a name="ln2335">			doIt) != doIt) {</a>
<a name="ln2336">		fAppSettings-&gt;SetValue(kSettingsKeyAutoHideInterfaceInFullscreenMode,</a>
<a name="ln2337">			doIt);</a>
<a name="ln2338">	}</a>
<a name="ln2339"> </a>
<a name="ln2340">	if (fAutoHideInterfaceInFullscreenMode) {</a>
<a name="ln2341">		BMessage message(CHECK_AUTO_HIDE_INTERFACE);</a>
<a name="ln2342">		fPulseRunner = new BMessageRunner(BMessenger(this), &amp;message, 300000);</a>
<a name="ln2343">	} else {</a>
<a name="ln2344">		delete fPulseRunner;</a>
<a name="ln2345">		fPulseRunner = NULL;</a>
<a name="ln2346">		_ShowInterface(true);</a>
<a name="ln2347">	}</a>
<a name="ln2348">}</a>
<a name="ln2349"> </a>
<a name="ln2350"> </a>
<a name="ln2351">void</a>
<a name="ln2352">BrowserWindow::_CheckAutoHideInterface()</a>
<a name="ln2353">{</a>
<a name="ln2354">	if (!fIsFullscreen || !fAutoHideInterfaceInFullscreenMode</a>
<a name="ln2355">		|| (CurrentWebView() != NULL &amp;&amp; !CurrentWebView()-&gt;IsFocus())) {</a>
<a name="ln2356">		return;</a>
<a name="ln2357">	}</a>
<a name="ln2358"> </a>
<a name="ln2359">	if (fLastMousePos.y == 0)</a>
<a name="ln2360">		_ShowInterface(true);</a>
<a name="ln2361">	else if (fNavigationGroup-&gt;IsVisible()</a>
<a name="ln2362">		&amp;&amp; fLastMousePos.y &gt; fNavigationGroup-&gt;Frame().bottom</a>
<a name="ln2363">		&amp;&amp; system_time() - fLastMouseMovedTime &gt; 1000000) {</a>
<a name="ln2364">		// NOTE: Do not re-use navigationGroupBottom in the above</a>
<a name="ln2365">		// check, since we only want to hide the interface when it is visible.</a>
<a name="ln2366">		_ShowInterface(false);</a>
<a name="ln2367">	}</a>
<a name="ln2368">}</a>
<a name="ln2369"> </a>
<a name="ln2370"> </a>
<a name="ln2371">void</a>
<a name="ln2372">BrowserWindow::_ShowInterface(bool show)</a>
<a name="ln2373">{</a>
<a name="ln2374">	if (fInterfaceVisible == show)</a>
<a name="ln2375">		return;</a>
<a name="ln2376"> </a>
<a name="ln2377">	fInterfaceVisible = show;</a>
<a name="ln2378"> </a>
<a name="ln2379">	if (show) {</a>
<a name="ln2380">#if !INTEGRATE_MENU_INTO_TAB_BAR</a>
<a name="ln2381">		fMenuGroup-&gt;SetVisible(</a>
<a name="ln2382">			(fVisibleInterfaceElements &amp; INTERFACE_ELEMENT_MENU) != 0);</a>
<a name="ln2383">#endif</a>
<a name="ln2384">		fTabGroup-&gt;SetVisible(_TabGroupShouldBeVisible());</a>
<a name="ln2385">		fNavigationGroup-&gt;SetVisible(</a>
<a name="ln2386">			(fVisibleInterfaceElements &amp; INTERFACE_ELEMENT_NAVIGATION) != 0);</a>
<a name="ln2387">		fStatusGroup-&gt;SetVisible(</a>
<a name="ln2388">			(fVisibleInterfaceElements &amp; INTERFACE_ELEMENT_STATUS) != 0);</a>
<a name="ln2389">	} else {</a>
<a name="ln2390">		fMenuGroup-&gt;SetVisible(false);</a>
<a name="ln2391">		fTabGroup-&gt;SetVisible(false);</a>
<a name="ln2392">		fNavigationGroup-&gt;SetVisible(false);</a>
<a name="ln2393">		fStatusGroup-&gt;SetVisible(false);</a>
<a name="ln2394">	}</a>
<a name="ln2395">	// TODO: Setting the group visible seems to unhide the status bar.</a>
<a name="ln2396">	// Fix in Haiku?</a>
<a name="ln2397">	while (!fLoadingProgressBar-&gt;IsHidden())</a>
<a name="ln2398">		fLoadingProgressBar-&gt;Hide();</a>
<a name="ln2399">}</a>
<a name="ln2400"> </a>
<a name="ln2401"> </a>
<a name="ln2402">void</a>
<a name="ln2403">BrowserWindow::_ShowProgressBar(bool show)</a>
<a name="ln2404">{</a>
<a name="ln2405">	if (show) {</a>
<a name="ln2406">		if (!fStatusGroup-&gt;IsVisible() &amp;&amp; (fVisibleInterfaceElements</a>
<a name="ln2407">			&amp; INTERFACE_ELEMENT_STATUS) != 0)</a>
<a name="ln2408">				fStatusGroup-&gt;SetVisible(true);</a>
<a name="ln2409">		fLoadingProgressBar-&gt;Show();</a>
<a name="ln2410">	} else {</a>
<a name="ln2411">		if (!fInterfaceVisible)</a>
<a name="ln2412">			fStatusGroup-&gt;SetVisible(false);</a>
<a name="ln2413">		// TODO: This is also used in _ShowInterface. Without it the status bar</a>
<a name="ln2414">		// doesn't always hide again. It may be an Interface Kit bug.</a>
<a name="ln2415">		while (!fLoadingProgressBar-&gt;IsHidden())</a>
<a name="ln2416">			fLoadingProgressBar-&gt;Hide();</a>
<a name="ln2417">	}</a>
<a name="ln2418">}</a>
<a name="ln2419"> </a>
<a name="ln2420"> </a>
<a name="ln2421">void</a>
<a name="ln2422">BrowserWindow::_InvokeButtonVisibly(BButton* button)</a>
<a name="ln2423">{</a>
<a name="ln2424">	button-&gt;SetValue(B_CONTROL_ON);</a>
<a name="ln2425">	UpdateIfNeeded();</a>
<a name="ln2426">	button-&gt;Invoke();</a>
<a name="ln2427">	snooze(1000);</a>
<a name="ln2428">	button-&gt;SetValue(B_CONTROL_OFF);</a>
<a name="ln2429">}</a>
<a name="ln2430"> </a>
<a name="ln2431"> </a>
<a name="ln2432">BString</a>
<a name="ln2433">BrowserWindow::_NewTabURL(bool isNewWindow) const</a>
<a name="ln2434">{</a>
<a name="ln2435">	BString url;</a>
<a name="ln2436">	uint32 policy = isNewWindow ? fNewWindowPolicy : fNewTabPolicy;</a>
<a name="ln2437">	// Implement new page policy</a>
<a name="ln2438">	switch (policy) {</a>
<a name="ln2439">		case OpenStartPage:</a>
<a name="ln2440">			url = fStartPageURL;</a>
<a name="ln2441">			break;</a>
<a name="ln2442">		case OpenSearchPage:</a>
<a name="ln2443">			url.SetTo(fSearchPageURL);</a>
<a name="ln2444">			url.ReplaceAll(&quot;%s&quot;, &quot;&quot;);</a>
<a name="ln2445">			break;</a>
<a name="ln2446">		case CloneCurrentPage:</a>
<a name="ln2447">			if (CurrentWebView() != NULL)</a>
<a name="ln2448">				url = CurrentWebView()-&gt;MainFrameURL();</a>
<a name="ln2449">			break;</a>
<a name="ln2450">		case OpenBlankPage:</a>
<a name="ln2451">		default:</a>
<a name="ln2452">			break;</a>
<a name="ln2453">	}</a>
<a name="ln2454">	return url;</a>
<a name="ln2455">}</a>
<a name="ln2456"> </a>
<a name="ln2457"> </a>
<a name="ln2458">BString</a>
<a name="ln2459">BrowserWindow::_EncodeURIComponent(const BString&amp; search)</a>
<a name="ln2460">{</a>
<a name="ln2461">	// We have to take care of some of the escaping before we hand over the</a>
<a name="ln2462">	// search string to WebKit, if we want queries like &quot;4+3&quot; to not be</a>
<a name="ln2463">	// searched as &quot;4 3&quot;.</a>
<a name="ln2464">	const BString escCharList = &quot; $&amp;`:&lt;&gt;[]{}\&quot;+#%@/;=?\\^|~\',&quot;;</a>
<a name="ln2465">	BString result = search;</a>
<a name="ln2466">	char hexcode[4];</a>
<a name="ln2467"> </a>
<a name="ln2468">	for (int32 i = 0; i &lt; result.Length(); i++) {</a>
<a name="ln2469">		if (escCharList.FindFirst(result[i]) != B_ERROR) {</a>
<a name="ln2470">			sprintf(hexcode, &quot;%02X&quot;, (unsigned int)result[i]);</a>
<a name="ln2471">			result.SetByteAt(i, '%');</a>
<a name="ln2472">			result.Insert(hexcode, i + 1);</a>
<a name="ln2473">			i += 2;</a>
<a name="ln2474">		}</a>
<a name="ln2475">	}</a>
<a name="ln2476"> </a>
<a name="ln2477">	return result;</a>
<a name="ln2478">}</a>
<a name="ln2479"> </a>
<a name="ln2480"> </a>
<a name="ln2481">void</a>
<a name="ln2482">BrowserWindow::_VisitURL(const BString&amp; url)</a>
<a name="ln2483">{</a>
<a name="ln2484">	// fURLInputGroup-&gt;TextView()-&gt;SetText(url);</a>
<a name="ln2485">	CurrentWebView()-&gt;LoadURL(url.String());</a>
<a name="ln2486">}</a>
<a name="ln2487"> </a>
<a name="ln2488"> </a>
<a name="ln2489">void</a>
<a name="ln2490">BrowserWindow::_VisitSearchEngine(const BString&amp; search)</a>
<a name="ln2491">{</a>
<a name="ln2492">	BString engine(fSearchPageURL);</a>
<a name="ln2493">	engine.ReplaceAll(&quot;%s&quot;, _EncodeURIComponent(search).String());</a>
<a name="ln2494"> </a>
<a name="ln2495">	_VisitURL(engine);</a>
<a name="ln2496">}</a>
<a name="ln2497"> </a>
<a name="ln2498"> </a>
<a name="ln2499">inline bool</a>
<a name="ln2500">BrowserWindow::_IsValidDomainChar(char ch)</a>
<a name="ln2501">{</a>
<a name="ln2502">	// TODO: Currenlty, only a whitespace character breaks a domain name. It</a>
<a name="ln2503">	// might be a good idea (or a bad one) to make character filtering based on</a>
<a name="ln2504">	// the IDNA 2008 standard.</a>
<a name="ln2505"> </a>
<a name="ln2506">	return ch != ' ';</a>
<a name="ln2507">}</a>
<a name="ln2508"> </a>
<a name="ln2509"> </a>
<a name="ln2510">/*! \brief &quot;smart&quot; parser for user-entered URLs</a>
<a name="ln2511"> </a>
<a name="ln2512">	We try to be flexible in what we accept as a valid URL. The protocol may</a>
<a name="ln2513">	be missing, or something we can't handle (in that case we run the matching</a>
<a name="ln2514">	app). If all attempts to make sense of the input fail, we make a search</a>
<a name="ln2515">	engine query for it.</a>
<a name="ln2516"> */</a>
<a name="ln2517">void</a>
<a name="ln2518">BrowserWindow::_SmartURLHandler(const BString&amp; url)</a>
<a name="ln2519">{</a>
<a name="ln2520">	// First test if the URL has a protocol field</a>
<a name="ln2521">	int32 at = url.FindFirst(&quot;:&quot;);</a>
<a name="ln2522"> </a>
<a name="ln2523">	if (at != B_ERROR) {</a>
<a name="ln2524">		// There is a protocol, let's see if we can handle it</a>
<a name="ln2525">		BString proto;</a>
<a name="ln2526">		url.CopyInto(proto, 0, at);</a>
<a name="ln2527"> </a>
<a name="ln2528">		bool handled = false;</a>
<a name="ln2529"> </a>
<a name="ln2530">		// First try the built-in supported ones</a>
<a name="ln2531">		for (unsigned int i = 0; i &lt; sizeof(kHandledProtocols) / sizeof(char*);</a>
<a name="ln2532">				i++) {</a>
<a name="ln2533">			handled = (proto == kHandledProtocols[i]);</a>
<a name="ln2534">			if (handled)</a>
<a name="ln2535">				break;</a>
<a name="ln2536">		}</a>
<a name="ln2537"> </a>
<a name="ln2538">		if (handled) {</a>
<a name="ln2539">			// This is the easy case, a complete and well-formed URL, we can</a>
<a name="ln2540">			// navigate to it without further efforts.</a>
<a name="ln2541">			_VisitURL(url);</a>
<a name="ln2542">			return;</a>
<a name="ln2543">		} else {</a>
<a name="ln2544">			// There is what looks like a protocol, but one we don't know.</a>
<a name="ln2545">			// Ask the BRoster if there is a matching filetype and app which</a>
<a name="ln2546">			// can handle it.</a>
<a name="ln2547">			BString temp;</a>
<a name="ln2548">			temp = &quot;application/x-vnd.Be.URL.&quot;;</a>
<a name="ln2549">			temp += proto;</a>
<a name="ln2550"> </a>
<a name="ln2551">			const char* argv[] = { url.String(), NULL };</a>
<a name="ln2552"> </a>
<a name="ln2553">			if (be_roster-&gt;Launch(temp.String(), 1, argv) == B_OK)</a>
<a name="ln2554">				return;</a>
<a name="ln2555">		}</a>
<a name="ln2556">	}</a>
<a name="ln2557"> </a>
<a name="ln2558">	// There is no protocol or only an unsupported one. So let's try harder to</a>
<a name="ln2559">	// guess what the request is.</a>
<a name="ln2560"> </a>
<a name="ln2561">	// &quot;localhost&quot; is a special case, it is a valid domain name but has no dots.</a>
<a name="ln2562">	// Handle it separately.</a>
<a name="ln2563">	if (url == &quot;localhost&quot;)</a>
<a name="ln2564">		_VisitURL(&quot;http://localhost/&quot;);</a>
<a name="ln2565">	else {</a>
<a name="ln2566">		// Also handle URLs starting with &quot;localhost&quot; followed by a path.</a>
<a name="ln2567">		const char* localhostPrefix = &quot;localhost/&quot;;</a>
<a name="ln2568"> </a>
<a name="ln2569">		if (url.Compare(localhostPrefix, strlen(localhostPrefix)) == 0)</a>
<a name="ln2570">			_VisitURL(url);</a>
<a name="ln2571">		else {</a>
<a name="ln2572">			// In all other cases we try to detect a valid domain name. There</a>
<a name="ln2573">			// must be at least one dot and no spaces until the first / in the</a>
<a name="ln2574">			// URL.</a>
<a name="ln2575">			bool isURL = false;</a>
<a name="ln2576"> </a>
<a name="ln2577">			for (int32 i = 0; i &lt; url.CountChars(); i++) {</a>
<a name="ln2578">				if (url[i] == '.')</a>
<a name="ln2579">					isURL = true;</a>
<a name="ln2580">				else if (url[i] == '/')</a>
<a name="ln2581">					break;</a>
<a name="ln2582">				else if (!_IsValidDomainChar(url[i])) {</a>
<a name="ln2583">					isURL = false;</a>
<a name="ln2584"> </a>
<a name="ln2585">					break;</a>
<a name="ln2586">				}</a>
<a name="ln2587">			}</a>
<a name="ln2588"> </a>
<a name="ln2589">			if (isURL) {</a>
<a name="ln2590">				// This is apparently an URL missing the protocol part. In that</a>
<a name="ln2591">				// case we default to http.</a>
<a name="ln2592">				BString prefixed = &quot;http://&quot;;</a>
<a name="ln2593">				prefixed &lt;&lt; url;</a>
<a name="ln2594">				_VisitURL(prefixed);</a>
<a name="ln2595">				return;</a>
<a name="ln2596">			} else {</a>
<a name="ln2597">				// We couldn't find anything that looks like an URL. Let's</a>
<a name="ln2598">				// assume what we have is a search request and go to the search</a>
<a name="ln2599">				// engine.</a>
<a name="ln2600">				_VisitSearchEngine(url);</a>
<a name="ln2601">			}</a>
<a name="ln2602">		}</a>
<a name="ln2603">	}</a>
<a name="ln2604">}</a>
<a name="ln2605"> </a>
<a name="ln2606"> </a>
<a name="ln2607">void</a>
<a name="ln2608">BrowserWindow::_HandlePageSourceResult(const BMessage* message)</a>
<a name="ln2609">{</a>
<a name="ln2610">	// TODO: This should be done in an extra thread perhaps. Doing it in</a>
<a name="ln2611">	// the application thread is not much better, since it actually draws</a>
<a name="ln2612">	// the pages...</a>
<a name="ln2613"> </a>
<a name="ln2614">	BPath pathToPageSource;</a>
<a name="ln2615"> </a>
<a name="ln2616">	BString url;</a>
<a name="ln2617">	status_t ret = message-&gt;FindString(&quot;url&quot;, &amp;url);</a>
<a name="ln2618">	if (ret == B_OK &amp;&amp; url.FindFirst(&quot;file://&quot;) == 0) {</a>
<a name="ln2619">		// Local file</a>
<a name="ln2620">		url.Remove(0, strlen(&quot;file://&quot;));</a>
<a name="ln2621">		pathToPageSource.SetTo(url.String());</a>
<a name="ln2622">	} else {</a>
<a name="ln2623">		// Something else, store it.</a>
<a name="ln2624">		// TODO: What if it isn't HTML, but for example SVG?</a>
<a name="ln2625">		BString source;</a>
<a name="ln2626">		ret = message-&gt;FindString(&quot;source&quot;, &amp;source);</a>
<a name="ln2627"> </a>
<a name="ln2628">		if (ret == B_OK)</a>
<a name="ln2629">			ret = find_directory(B_SYSTEM_TEMP_DIRECTORY, &amp;pathToPageSource);</a>
<a name="ln2630"> </a>
<a name="ln2631">		BString tmpFileName(&quot;PageSource_&quot;);</a>
<a name="ln2632">		tmpFileName &lt;&lt; system_time() &lt;&lt; &quot;.html&quot;;</a>
<a name="ln2633">		if (ret == B_OK)</a>
<a name="ln2634">			ret = pathToPageSource.Append(tmpFileName.String());</a>
<a name="ln2635"> </a>
<a name="ln2636">		BFile pageSourceFile(pathToPageSource.Path(),</a>
<a name="ln2637">			B_CREATE_FILE | B_ERASE_FILE | B_WRITE_ONLY);</a>
<a name="ln2638">		if (ret == B_OK)</a>
<a name="ln2639">			ret = pageSourceFile.InitCheck();</a>
<a name="ln2640"> </a>
<a name="ln2641">		if (ret == B_OK) {</a>
<a name="ln2642">			ssize_t written = pageSourceFile.Write(source.String(),</a>
<a name="ln2643">				source.Length());</a>
<a name="ln2644">			if (written != source.Length())</a>
<a name="ln2645">				ret = (status_t)written;</a>
<a name="ln2646">		}</a>
<a name="ln2647"> </a>
<a name="ln2648">		if (ret == B_OK) {</a>
<a name="ln2649">			const char* type = &quot;text/html&quot;;</a>
<a name="ln2650">			size_t size = strlen(type);</a>
<a name="ln2651">			pageSourceFile.WriteAttr(&quot;BEOS:TYPE&quot;, B_STRING_TYPE, 0, type, size);</a>
<a name="ln2652">				// If it fails we don't care.</a>
<a name="ln2653">		}</a>
<a name="ln2654">	}</a>
<a name="ln2655"> </a>
<a name="ln2656">	entry_ref ref;</a>
<a name="ln2657">	if (ret == B_OK)</a>
<a name="ln2658">		ret = get_ref_for_path(pathToPageSource.Path(), &amp;ref);</a>
<a name="ln2659"> </a>
<a name="ln2660">	if (ret == B_OK) {</a>
<a name="ln2661">		BMessage refsMessage(B_REFS_RECEIVED);</a>
<a name="ln2662">		ret = refsMessage.AddRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln2663">		if (ret == B_OK) {</a>
<a name="ln2664">			ret = be_roster-&gt;Launch(&quot;text/x-source-code&quot;, &amp;refsMessage);</a>
<a name="ln2665">			if (ret == B_ALREADY_RUNNING)</a>
<a name="ln2666">				ret = B_OK;</a>
<a name="ln2667">		}</a>
<a name="ln2668">	}</a>
<a name="ln2669"> </a>
<a name="ln2670">	if (ret != B_OK) {</a>
<a name="ln2671">		char buffer[1024];</a>
<a name="ln2672">		snprintf(buffer, sizeof(buffer), &quot;Failed to show the &quot;</a>
<a name="ln2673">			&quot;page source: %s\n&quot;, strerror(ret));</a>
<a name="ln2674">		BAlert* alert = new BAlert(B_TRANSLATE(&quot;Page source error&quot;), buffer,</a>
<a name="ln2675">			B_TRANSLATE(&quot;OK&quot;));</a>
<a name="ln2676">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2677">		alert-&gt;Go(NULL);</a>
<a name="ln2678">	}</a>
<a name="ln2679">}</a>
<a name="ln2680"> </a>
<a name="ln2681"> </a>
<a name="ln2682">void</a>
<a name="ln2683">BrowserWindow::_ShowBookmarkBar(bool show)</a>
<a name="ln2684">{</a>
<a name="ln2685">	// It is not allowed to show the bookmark bar when it is empty</a>
<a name="ln2686">	if (show &amp;&amp; (fBookmarkBar == NULL || fBookmarkBar-&gt;CountItems() &lt;= 1))</a>
<a name="ln2687">	{</a>
<a name="ln2688">		fBookmarkBarMenuItem-&gt;SetMarked(false);</a>
<a name="ln2689">		return;</a>
<a name="ln2690">	}</a>
<a name="ln2691"> </a>
<a name="ln2692">	fBookmarkBarMenuItem-&gt;SetMarked(show);</a>
<a name="ln2693"> </a>
<a name="ln2694">	if (fBookmarkBar == NULL || fBookmarkBar-&gt;IsHidden() != show)</a>
<a name="ln2695">		return;</a>
<a name="ln2696"> </a>
<a name="ln2697">	fAppSettings-&gt;SetValue(kSettingsShowBookmarkBar, show);</a>
<a name="ln2698"> </a>
<a name="ln2699">	if (show)</a>
<a name="ln2700">		fBookmarkBar-&gt;Show();</a>
<a name="ln2701">	else</a>
<a name="ln2702">		fBookmarkBar-&gt;Hide();</a>
<a name="ln2703">}</a>

</code></pre>
<div class="balloon" rel="948"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="2678"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1791"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'panel' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1897"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="2023"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="2049"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1928"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
